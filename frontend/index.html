<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journal Article AI Assistant</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: false, 
            theme: 'default',
            securityLevel: 'loose',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
        });
        window.mermaid = mermaid;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            background: #f5f5f5;
            overflow-x: hidden;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s;
        }

        .sidebar.collapsed {
            margin-left: -300px;
        }

        .sessions-sidebar {
            width: 280px;
            background: white;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-right 0.3s;
        }

        .sessions-sidebar.collapsed {
            margin-right: -280px;
        }

        .sessions-header {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sessions-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .sessions-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .session-item {
            padding: 12px;
            margin-bottom: 6px;
            background: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 2px solid transparent;
        }

        .session-item:hover {
            background: #f0f0f0;
        }

        .session-item.active {
            background: #e3f2fd;
            border-color: #007bff;
        }

        .session-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 4px;
        }

        .session-id-label {
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #666;
        }

        .session-delete-btn {
            background: transparent;
            border: none;
            color: #b00020;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
            line-height: 1;
        }

        .session-delete-btn:hover {
            color: #8b0000;
        }

        .session-meta {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        .new-session-btn {
            width: 100%;
            padding: 10px;
            margin: 8px;
            margin-top: 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .new-session-btn:hover {
            background: #0056b3;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-direction: column;
            gap: 12px;
        }

        .sidebar-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .index-button {
            width: 100%;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .index-button:hover {
            background: #0056b3;
        }

        .index-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .index-button.secondary {
            background: #6c757d;
        }

        .index-button.secondary:hover {
            background: #5a6268;
        }

        .progress-container {
            padding: 12px 20px;
            border-top: 1px solid #e0e0e0;
            background: #f9f9f9;
            display: none;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #555;
            margin-bottom: 6px;
        }

        .progress-track {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }

        .papers-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .paper-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 2px solid transparent;
        }

        .paper-item:hover {
            background: #f0f0f0;
        }

        .paper-item.selected {
            background: #e3f2fd;
            border-color: #007bff;
        }

        .paper-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .paper-meta {
            font-size: 12px;
            color: #666;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-sidebar {
            padding: 8px 16px;
            background: #f0f0f0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .toggle-sidebar:hover {
            background: #e0e0e0;
        }

        .toggle-sidebar.has-notes {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }

        .danger-button {
            padding: 8px 16px;
            background: #dc3545;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 0 0 1px rgba(220, 53, 69, 0.4);
        }

        .danger-button:hover {
            background: #b02a37;
        }

        .stats {
            font-size: 14px;
            color: #666;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: relative;
            transition: background 0.3s ease;
        }

        .chat-container.specialized {
            background-color: #f8fbff;
            background-image: radial-gradient(#d0e0f0 1.5px, transparent 1.5px);
            background-size: 24px 24px;
        }

        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
            position: relative;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .message.user {
            align-self: flex-end;
            background: #007bff;
            color: white;
        }

        .message.assistant {
            align-self: flex-start;
            background: #f0f0f0;
            color: #333;
            max-width: 95%;
        }

        .copy-button {
            position: absolute;
            top: 6px;
            right: 6px;
            background: #ffffffcc;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 6px;
            opacity: 0;
            transition: opacity 0.15s ease, background-color 0.15s ease;
            color: #333;
        }

        .message-delete-btn {
            position: absolute;
            top: 6px;
            right: 34px;
            background: #ffffffcc;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 6px;
            opacity: 0;
            transition: opacity 0.15s ease, background-color 0.15s ease;
            color: #b00020;
        }

        .message:hover .message-delete-btn {
            opacity: 1;
        }

        .message-delete-btn:hover {
            background: #ffebee;
            border-color: #ffcdd2;
        }

        .message:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background: #f3f3f3;
        }

        .copy-button.copied {
            background: #e6ffe6;
        }

        .message-content {
            line-height: 1.6;
        }

        .message-content h1,
        .message-content h2,
        .message-content h3 {
            margin-top: 16px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .message-content h1 {
            font-size: 1.5em;
        }

        .message-content h2 {
            font-size: 1.3em;
        }

        .message-content h3 {
            font-size: 1.1em;
        }

        .message-content p {
            margin-bottom: 12px;
        }

        .message-content ul,
        .message-content ol {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .message-content li {
            margin-bottom: 4px;
        }

        .message-content code {
            background: #e8e8e8;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .message-content pre {
            background: #f6f8fa;
            color: #24292e;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 12px;
            position: relative;
            border: 1px solid #e1e4e8;
            max-width: 100%;
        }

        .message-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
        }

        .mermaid {
            background: white;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .code-copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ffffff33;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            padding: 2px 6px;
            color: #f8f8f8;
            opacity: 0;
            transition: opacity 0.15s ease, background-color 0.15s ease;
        }

        .message-content pre:hover .code-copy-button {
            opacity: 1;
        }

        .code-copy-button.copied {
            background: #4caf50;
            border-color: #4caf50;
        }

        .message-content blockquote {
            border-left: 4px solid #007bff;
            padding-left: 12px;
            margin-left: 0;
            margin-bottom: 12px;
            color: #666;
            font-style: italic;
        }

        .message-content strong {
            font-weight: 600;
        }

        .message-content em {
            font-style: italic;
        }

        .message-content a {
            color: #007bff;
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .message-content table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
        }

        .message-content th,
        .message-content td {
            border: 1px solid #ccc;
            padding: 6px 8px;
            text-align: left;
            font-size: 13px;
            min-width: 100px;
        }

        .message-content thead {
            background-color: #f5f5f5;
            font-weight: 600;
        }

        /* Interactive Table Styles */
        .interactive-table th {
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .interactive-table th:hover {
            background-color: #e9ecef;
        }
        .interactive-table th::after {
            content: '‚Üï';
            font-size: 10px;
            margin-left: 5px;
            opacity: 0.3;
            float: right;
            margin-right: 10px;
        }
        .interactive-table th.asc::after {
            content: '‚Üë';
            opacity: 1;
        }
        .interactive-table th.desc::after {
            content: '‚Üì';
            opacity: 1;
        }
        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            background: transparent;
            z-index: 1;
        }
        .resize-handle:hover,
        .resize-handle.active {
            background: #007bff;
        }

        .message-sources {
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.8;
        }

        .input-container {
            padding: 24px;
            display: flex;
            justify-content: center;
            background: white;
        }

        .input-wrapper {
            position: relative;
            width: 100%;
            max-width: 768px;
            display: flex;
            align-items: flex-end;
            background: #f4f4f4;
            border-radius: 26px;
            padding: 10px;
            border: 1px solid transparent;
            transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
        }

        .input-wrapper:focus-within {
            border-color: #d9d9d9;
            background: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .input-box {
            flex: 1;
            padding: 4px 8px;
            padding-right: 40px;
            border: none;
            background: transparent;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .input-box:focus {
            outline: none;
        }

        .send-button {
            position: absolute;
            right: 8px;
            bottom: 8px;
            width: 32px;
            height: 32px;
            background: #e5e5e5;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: default;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .send-button.active {
            background: #007bff;
            cursor: pointer;
        }

        .send-button.active:hover {
            background: #0056b3;
        }

        .send-button svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        .loading {
            padding: 12px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .scroll-to-bottom {
            position: fixed;
            right: 24px;
            bottom: 96px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid #ddd;
            background: #ffffffee;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
            display: none;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .scroll-to-bottom span {
            font-size: 14px;
        }

        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 14px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            width: 600px;
            max-width: 90%;
            height: 80vh;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .modal-header {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            flex: 1;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        .notes-textarea {
            flex: 1;
            width: 100%;
            resize: none;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: #007bff;
        }

        .modal-footer {
            padding: 16px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* Image Modal Styles */
        #imageModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        #imageModal .modal-content {
            width: 95vw;
            height: 95vh;
            max-width: none;
            background: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #imageModal .modal-header {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #imageModal .modal-header h3 {
            font-size: 18px;
            font-weight: 600;
        }

        #imageModal .modal-body {
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            padding: 0;
        }

        #imageModal img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title-row">
                <h2>Papers</h2>
                <span id="paperCount">0</span>
            </div>
            <input 
                type="file" 
                id="paperUploadInput" 
                accept="application/pdf" 
                multiple 
                style="display:none" 
            >
            <button class="index-button secondary" id="uploadButton" onclick="triggerPaperUpload()" style="width: 100%;">
                ‚¨ÜÔ∏è Upload PDFs
            </button>
            <div style="display: flex; gap: 8px; width: 100%;">
                <button class="index-button secondary" id="mindmapButton" onclick="openMindmap()" style="flex: 1;">
                    üß† View Mindmap
                </button>
                <button class="index-button secondary" id="mindmapQueryButton" onclick="editMindmapQuery()" title="Edit mindmap instructions" style="width: 40px; padding: 0; display: flex; align-items: center; justify-content: center;">
                    ‚úèÔ∏è
                </button>
            </div>
        </div>
        
        <div id="progressContainer" class="progress-container">
            <div class="progress-header">
                <span id="progressStatus">Processing...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-track">
                <div id="progressBar" class="progress-fill"></div>
            </div>
        </div>

        <div class="papers-list" id="papersList">
            <div class="empty-state">Upload PDFs via the button or drop them here</div>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
            <div style="display: flex; gap: 12px; align-items: center;">
                <button class="toggle-sidebar" onclick="toggleSessionsSidebar()">üí¨ Sessions</button>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚ò∞ Papers</button>
                <button class="toggle-sidebar" id="notesButton" onclick="openNotes()">üìù Notes</button>
            </div>
            <div class="stats">
                <button class="toggle-sidebar" style="margin-right: 12px;" onclick="clearChat()">üßπ Clear Chat</button>
                <button class="danger-button" style="background: #ff9800; margin-right: 12px;" onclick="pruneData()">‚úÇ Prune Data</button>
                <button class="danger-button" onclick="resetAllData()">‚ö† Reset All Data</button>
            </div>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="empty-state">Ask a question about the papers</div>
        </div>
        <button class="scroll-to-bottom" id="scrollToBottomButton" onclick="scrollToBottom()">
            <span>‚Üì</span> New messages
        </button>

        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    class="input-box" 
                    id="messageInput" 
                    placeholder="Message Journal Assistant..."
                    rows="1"
                ></textarea>
                <button class="send-button" id="sendButton" onclick="sendMessage()" disabled>
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div class="sessions-sidebar" id="sessionsSidebar">
        <div class="sessions-header">
            <h3>üí¨ Sessions</h3>
            <button class="toggle-sidebar" style="padding: 4px 8px; font-size: 12px;" onclick="toggleSessionsSidebar()">‚úï</button>
        </div>
        <button class="new-session-btn" onclick="newSession()">Ôºã New Session</button>
        <button class="new-session-btn" onclick="duplicateSession()" style="background: #6c757d; margin-top: 0;">‚ùê Duplicate Session</button>
        <div class="sessions-list" id="sessionsList">
            <div class="empty-state" style="padding: 20px; text-align: center; color: #999; font-size: 13px;">No saved sessions</div>
        </div>
    </div>

    <!-- Notes Modal -->
    <div class="modal-overlay" id="notesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Session Notes</h3>
                <button class="toggle-sidebar" style="padding: 4px 8px;" onclick="closeNotes()">‚úï</button>
            </div>
            <div class="modal-body">
                <textarea class="notes-textarea" id="sessionNotes" placeholder="Add notes for this session..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="index-button secondary" onclick="closeNotes()" style="width: auto;">Close</button>
                <button class="index-button" onclick="saveNotes()" style="width: auto;">Save Notes</button>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div class="modal-overlay" id="imageModal" onclick="closeImageModal()">
        <div class="modal-content" style="width: 95vw; height: 95vh; max-width: none; background: white; overflow: hidden; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>Diagram View</h3>
                <button class="toggle-sidebar" style="padding: 4px 8px;" onclick="closeImageModal()">‚úï</button>
            </div>
            <div class="modal-body" id="imageModalBody" style="overflow: auto; display: flex; align-items: center; justify-content: center; background: #fff; padding: 0;">
                <!-- Content goes here -->
            </div>
        </div>
    </div>

    <script>
        // Configure marked globally if available
        if (typeof marked !== 'undefined') {
            marked.use({
                breaks: true,
                gfm: true,
                highlight: function(code, lang) {
                    if (typeof hljs !== 'undefined') {
                        const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                        return hljs.highlight(code, { language }).value;
                    }
                    return code;
                },
                langPrefix: 'hljs language-'
            });

            const renderer = {
                code(tokenOrCode, language, isEscaped) {
                    // Handle Marked v12+ (object argument) vs older versions (string arguments)
                    let codeStr = '';
                    let lang = '';
                    
                    if (typeof tokenOrCode === 'object' && tokenOrCode !== null && !Array.isArray(tokenOrCode)) {
                        codeStr = (tokenOrCode.text || '').toString();
                        lang = (tokenOrCode.lang || '').toString();
                    } else {
                        codeStr = (tokenOrCode || '').toString();
                        lang = (language || '').toString();
                    }

                    lang = lang.trim().toLowerCase();
                    
                    // Robust Mermaid detection
                    const isExplicitMermaid = lang === 'mermaid';
                    
                    // Check for mermaid keywords at the start of the code
                    const firstLine = codeStr.trim().split('\n')[0].trim();
                    const mermaidKeywords = [
                        'graph', 'flowchart', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 
                        'stateDiagram-v2', 'gantt', 'pie', 'erDiagram', 'journey', 'gitGraph', 
                        'mindmap', 'timeline', 'c4context', 'zenuml', 'sankey-beta', 'xychart-beta', 
                        'block-beta', 'packet-beta', 'kanban', 'architecture-beta', 'requirementDiagram'
                    ];
                    
                    const isMermaidKeyword = mermaidKeywords.some(k => {
                        const regex = new RegExp(`^${k}(\\s|$)`, 'i');
                        return regex.test(firstLine);
                    });
                    
                    const isMermaidDirective = firstLine.startsWith('%%');

                    if (isExplicitMermaid || isMermaidKeyword || isMermaidDirective) {
                        return `<div class="mermaid">${codeStr}</div>`;
                    }
                    
                    // Default code rendering with Highlight.js
                    const validLang = (lang && typeof hljs !== 'undefined' && hljs.getLanguage(lang)) ? lang : '';
                    const langClass = validLang ? 'hljs language-' + validLang : 'hljs';
                    
                    let highlighted = codeStr;
                    if (validLang) {
                        try {
                            highlighted = hljs.highlight(codeStr, { language: validLang }).value;
                        } catch (e) {}
                    }
                    
                    return `<pre><code class="${langClass}">${highlighted}</code></pre>`;
                }
            };
            marked.use({ renderer });
        }

        const API_URL = 'http://localhost:8000/api';
        let sessionId = null;
        let isLoading = false;
        let isIndexing = false;
        let isStreaming = false;
        let selectedPaperId = null; // Track selected paper ID
        let mindmapQuery = '';
        let lastMindmapQuery = '';
        let autoScroll = true;
        let currentPaperIds = [];
        let activeSessionLabel = '';
        let currentNotes = '';
        let panZoomInstance = null;

        const LAST_SESSION_KEY = 'paper_cruncher_last_session_id';

        // Wire up upload input
        document.getElementById('paperUploadInput').addEventListener('change', (e) => {
            const files = Array.from(e.target.files || []);
            if (!files.length) return;
            uploadPapers(files);
        });

        // Enable drag-and-drop on the papers list
        const papersListEl = document.getElementById('papersList');
        papersListEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            papersListEl.style.background = '#eef6ff';
        });
        papersListEl.addEventListener('dragleave', (e) => {
            e.preventDefault();
            papersListEl.style.background = '';
        });
        papersListEl.addEventListener('drop', (e) => {
            e.preventDefault();
            papersListEl.style.background = '';
            const files = Array.from(e.dataTransfer.files || []);
            if (!files.length) return;
            uploadPapers(files);
        });

        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');

        function updateInputState() {
            const hasContent = messageInput.value.trim().length > 0;
            const isBusy = isLoading || isIndexing;
            
            if (hasContent && !isBusy) {
                sendButton.disabled = false;
                sendButton.classList.add('active');
            } else {
                sendButton.disabled = true;
                sendButton.classList.remove('active');
            }

            if (isIndexing) {
                messageInput.disabled = true;
                messageInput.placeholder = "Indexing papers... please wait";
            } else if (isLoading) {
                // Keep input enabled but placeholder indicates busy
                messageInput.disabled = false;
                messageInput.placeholder = "Waiting for response...";
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = "Message Journal Assistant...";
            }
        }

        function adjustHeight() {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 200) + 'px';
            updateInputState();
        }

        messageInput.addEventListener('input', adjustHeight);

        // Handle Enter key (Shift+Enter for new line)
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendButton.disabled) {
                    sendMessage();
                }
            }
        });

        const chatContainerEl = document.getElementById('chatContainer');
        const scrollBtnEl = document.getElementById('scrollToBottomButton');

        chatContainerEl.addEventListener('scroll', () => {
            const threshold = 80;
            const atBottom = chatContainerEl.scrollHeight - chatContainerEl.scrollTop - chatContainerEl.clientHeight < threshold;
            autoScroll = atBottom;
            scrollBtnEl.style.display = autoScroll ? 'none' : 'flex';
        });

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('collapsed');
        }

        function toggleSessionsSidebar() {
            const sidebar = document.getElementById('sessionsSidebar');
            const wasCollapsed = sidebar.classList.contains('collapsed');
            sidebar.classList.toggle('collapsed');
            
            // Load sessions when opening
            if (wasCollapsed) {
                loadSessionsList();
            }
        }

        function triggerPaperUpload() {
            const ensureSession = async () => {
                if (sessionId) return;
                try {
                    const res = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                    if (res.ok) {
                        const data = await res.json();
                        sessionId = data.session_id;
                        updateActiveSessionLabel(null, sessionId);
                        try { window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId); } catch {}
                        // Persist empty context so subsequent uploads attach cleanly
                        await saveSessionContext();
                    }
                } catch (e) {
                    console.warn('Could not ensure session before upload', e);
                }
            };

            ensureSession().finally(() => {
                const input = document.getElementById('paperUploadInput');
                input.value = '';
                input.click();
            });
        }

        async function uploadPapers(files) {
            const formData = new FormData();
            for (const file of files) {
                if (!file.name.toLowerCase().endsWith('.pdf')) continue;
                formData.append('files', file);
            }
            if (!formData.has('files')) return;
            if (sessionId) {
                formData.append('session_id', sessionId);
            }

            const uploadBtn = document.getElementById('uploadButton');
            const originalText = uploadBtn.textContent;
            uploadBtn.disabled = true;
            uploadBtn.textContent = '‚è≥ Uploading...';
            
            isIndexing = true;
            updateInputState();

            try {
                const response = await fetch(`${API_URL}/papers/upload`, {
                    method: 'POST',
                    body: formData,
                });
                if (!response.ok) {
                    throw new Error('Failed to upload papers');
                }

                const data = await response.json();
                const uploadedIds = (data.papers || []).map(p => p.id);

                // Trust backend as source of truth: reload the full session
                if (sessionId) {
                    await loadSession(sessionId);
                } else {
                    // No session should be rare (we ensure before upload), fallback to show uploaded only
                    await loadPapers(uploadedIds);
                }

                uploadBtn.textContent = `‚úì Uploaded (${data.total_count})`;
                setTimeout(() => {
                    uploadBtn.textContent = originalText;
                }, 2000);
            } catch (error) {
                console.error('Error uploading papers:', error);
                uploadBtn.textContent = '‚úó Upload error';
                setTimeout(() => {
                    uploadBtn.textContent = originalText;
                }, 2000);
            } finally {
                uploadBtn.disabled = false;
                isIndexing = false;
                updateInputState();
            }
        }

        function openMindmap() {
            // Open the mindmap visualization in a new tab.
            // Always go through the query-based generation path so that
            // the default generic mindmap and custom queries behave
            // consistently and reflect the current papers.

            const baseDefault = 'Organize the content into meaningful themes and subtopics.';
            const trimmedQuery = (mindmapQuery || '').trim() || baseDefault;

            let url = '/mindmap';
            const qs = new URLSearchParams();

            // Always pass session_id to scope mindmap to current session's papers
            if (sessionId) {
                qs.set('session_id', sessionId);
            }

            // If a specific paper is selected, also pass paper_id for single-paper view
            if (selectedPaperId) {
                qs.set('paper_id', selectedPaperId);
            }

            // Always pass an explicit query so the backend uses the
            // same generation/caching pipeline for both default and
            // user-specified instructions.
            qs.set('query', trimmedQuery);

            const qsString = qs.toString();
            if (qsString) {
                url += `?${qsString}`;
            }

            window.open(url, '_blank');
        }

        function openCitationMap(paperId) {
            const targetId = paperId || selectedPaperId;
            if (!targetId) {
                alert('Please select a paper first to view its citation map.');
                return;
            }
            const url = `/mindmap?mode=citations&paper_id=${targetId}`;
            window.open(url, '_blank');
        }

        function editMindmapQuery() {
            const baseDefault = 'Organize the content into meaningful themes and subtopics.';
            const scopedDefault = 'Organize this paper\'s content into its main topics and subtopics.';
            const currentDefault = selectedPaperId ? scopedDefault : baseDefault;

            const existing = mindmapQuery && mindmapQuery.trim() ? mindmapQuery : currentDefault;
            const updated = window.prompt('Mindmap instructions (optional):', existing);
            if (updated === null) {
                return; // user cancelled
            }
            const trimmed = updated.trim();
            mindmapQuery = trimmed;
        }

        async function loadPapers(filterIds) {
            try {
                const response = await fetch(`${API_URL}/papers`);
                const data = await response.json();
                
                const papersList = document.getElementById('papersList');
                const paperCount = document.getElementById('paperCount');
                const allPapers = data.papers || [];

                // If filterIds is explicitly provided (even if empty), use it
                // Otherwise (undefined/null), show all papers
                const hasFilter = Array.isArray(filterIds);
                const effectiveIds = hasFilter ? new Set(filterIds) : null;

                const scopedPapers = hasFilter
                    ? allPapers.filter(p => effectiveIds.has(p.id))
                    : allPapers;

                // For session context, only track the IDs of the
                // papers actually visible in this view, not all
                // globally indexed papers. This keeps sessions
                // properly scoped even across multiple windows.
                currentPaperIds = scopedPapers.map(p => p.id);
                paperCount.textContent = scopedPapers.length;

                if (!scopedPapers.length) {
                    papersList.innerHTML = '<div class="empty-state">No papers available</div>';
                    return;
                }

                papersList.innerHTML = scopedPapers.map((paper, index) => {
                    // Prefer inferred_title if available, otherwise fallback to filename
                    let displayTitle = (paper.inferred_title && paper.inferred_title.trim()) 
                        ? paper.inferred_title 
                        : paper.filename;
                    
                    let displayFilename = paper.filename;

                    // Extract main author surname
                    let authorDisplay = '';
                    if (paper.authors && paper.authors.length > 0) {
                        const mainAuthor = paper.authors[0];
                        let surname = mainAuthor;
                        if (mainAuthor.includes(',')) {
                            surname = mainAuthor.split(',')[0].trim();
                        } else {
                            const parts = mainAuthor.trim().split(/\s+/);
                            surname = parts.length > 0 ? parts[parts.length - 1] : mainAuthor;
                        }
                        authorDisplay = surname + (paper.authors.length > 1 ? ' et al.' : '');
                    }

                    const authorSuffix = authorDisplay 
                        ? ` <span style="font-weight: normal; color: #666;">[<span style="font-style: italic;">${authorDisplay}</span>]</span>` 
                        : '';

                    // If we are using the filename as the title, don't show it again as a footnote
                    const filenameHtml = (displayFilename && displayFilename !== displayTitle)
                        ? `<div style="font-size: 10px; color: #999; margin-bottom: 6px; word-break: break-all; line-height: 1.3;">${displayFilename}</div>`
                        : '';

                    const hasFootnote = filenameHtml;

                    return `
                    <div class="paper-item" data-paper-id="${paper.id}" onclick="selectPaper('${paper.id}')" style="display: flex; flex-direction: column;">
                        <div style="display: flex; gap: 8px; align-items: flex-start; margin-bottom: ${hasFootnote ? '2px' : '6px'}; justify-content: space-between;">
                             <div class="paper-name" style="line-height: 1.35; font-size: 13px; flex-grow: 1;">${displayTitle}${authorSuffix}</div>
                             <span style="font-size: 11px; color: #555; background: #e0e0e0; padding: 1px 5px; border-radius: 4px; font-family: monospace; min-width: 24px; text-align: center; height: fit-content; margin-top: 2px; flex-shrink: 0;">${(index + 1).toString().padStart(2, '0')}</span>
                        </div>
                        ${filenameHtml}
                        
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: auto; padding-top: 4px; border-top: 1px solid #f0f0f0;">
                            <div class="paper-meta" style="font-size: 11px; color: #888;">${paper.publication_year ? paper.publication_year + ' ‚Ä¢ ' : ''}${paper.page_count} p.${(paper.citation_count !== undefined && paper.citation_count !== null && paper.citation_count > 0) ? ' ‚Ä¢ ' + paper.citation_count + ' cites' : ''}</div>
                            
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <button
                                    type="button"
                                    title="Open PDF"
                                    style="border: none; background: transparent; cursor: pointer; font-size: 14px; padding: 0; opacity: 0.6; display: flex; align-items: center;"
                                    onmouseover="this.style.opacity=1"
                                    onmouseout="this.style.opacity=0.6"
                                    onclick="event.stopPropagation(); window.open('/api/files/${encodeURIComponent(paper.filename)}', '_blank')"
                                >üìÑ</button>
                                <button
                                    type="button"
                                    title="View Citation Map"
                                    style="border: none; background: transparent; cursor: pointer; font-size: 14px; padding: 0; opacity: 0.6; display: flex; align-items: center;"
                                    onmouseover="this.style.opacity=1"
                                    onmouseout="this.style.opacity=0.6"
                                    onclick="event.stopPropagation(); openCitationMap('${paper.id}')"
                                >üï∏Ô∏è</button>
                                <button
                                    type="button"
                                    title="Remove from this chat session"
                                    style="border: none; background: transparent; color: #b00020; cursor: pointer; font-size: 14px; padding: 0; opacity: 0.6; display: flex; align-items: center;"
                                    onmouseover="this.style.opacity=1"
                                    onmouseout="this.style.opacity=0.6"
                                    onclick="event.stopPropagation(); removePaperFromSession('${paper.id}')"
                                >‚úï</button>
                            </div>
                        </div>
                    </div>
                `;}).join('');
            } catch (error) {
                console.error('Error loading papers:', error);
                papersList.innerHTML = '<div class="empty-state">Error loading papers</div>';
            }
        }

        async function selectPaper(paperId) {
            if (!sessionId) return;
            
            // Toggle selection
            const newSelection = selectedPaperId === paperId ? null : paperId;
            
            try {
                // Update backend first
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: newSelection,
                        paper_ids: currentPaperIds,
                    }),
                });
                
                if (res.ok) {
                    // Backend updated, reload session to sync UI
                    await loadSession(sessionId);
                }
            } catch (err) {
                console.error('Failed to update selected paper', err);
            }
        }

        function makeTablesInteractive(container) {
            const tables = container.querySelectorAll('table');
            tables.forEach(table => {
                if (table.classList.contains('interactive-processed')) return;
                table.classList.add('interactive-table', 'interactive-processed');
                
                // Enable sorting
                const headers = table.querySelectorAll('th');
                headers.forEach((th, index) => {
                    th.addEventListener('click', (e) => {
                        // Ignore if clicking resize handle
                        if (e.target.classList.contains('resize-handle')) return;
                        sortTable(table, index);
                    });
                    
                    // Add resize handle
                    const handle = document.createElement('div');
                    handle.className = 'resize-handle';
                    th.appendChild(handle);
                    enableResize(table, th, handle);
                });
            });
        }

        function sortTable(table, colIndex) {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const th = table.querySelectorAll('th')[colIndex];
            const isAsc = !th.classList.contains('asc');
            
            // Reset other headers
            table.querySelectorAll('th').forEach(h => h.classList.remove('asc', 'desc'));
            th.classList.toggle('asc', isAsc);
            th.classList.toggle('desc', !isAsc);
            
            rows.sort((a, b) => {
                const cellA = a.cells[colIndex]?.textContent.trim() || '';
                const cellB = b.cells[colIndex]?.textContent.trim() || '';
                
                // Try numeric sort
                const numA = parseFloat(cellA.replace(/[^0-9.-]+/g, ''));
                const numB = parseFloat(cellB.replace(/[^0-9.-]+/g, ''));
                
                // Check if both are valid numbers and the cell actually looks like a number
                // (to avoid parsing "Session 1" as just "1" and sorting numerically if it's mixed)
                const isNumA = !isNaN(numA) && cellA.match(/^[\d.,\s$%]+$/);
                const isNumB = !isNaN(numB) && cellB.match(/^[\d.,\s$%]+$/);

                if (isNumA && isNumB) {
                    return isAsc ? numA - numB : numB - numA;
                }
                
                return isAsc ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
            });
            
            rows.forEach(row => tbody.appendChild(row));
        }

        function enableResize(table, th, handle) {
            let startX, startWidth;
            
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation(); // Prevent sort trigger
                startX = e.pageX;
                startWidth = th.offsetWidth;
                handle.classList.add('active');
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            function onMouseMove(e) {
                const width = startWidth + (e.pageX - startX);
                if (width > 50) {
                    th.style.width = `${width}px`;
                    th.style.minWidth = `${width}px`;
                    // Force table to respect widths
                    table.style.tableLayout = 'fixed';
                    table.style.width = '100%';
                }
            }
            
            function onMouseUp() {
                handle.classList.remove('active');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        function renderMarkdownWithMath(text) {
            if (typeof marked === 'undefined') return text;
            
            // If KaTeX is not loaded, fallback to just markdown
            if (typeof katex === 'undefined') return marked.parse(text);

            const mathBlocks = [];
            
            // Protect block math $$...$$
            let protectedText = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, tex) => {
                mathBlocks.push({ type: 'display', tex: tex });
                return `MATHBLOCK${mathBlocks.length - 1}END`;
            });

            // Protect block math \[...\]
            protectedText = protectedText.replace(/\\\[([\s\S]*?)\\\]/g, (match, tex) => {
                mathBlocks.push({ type: 'display', tex: tex });
                return `MATHBLOCK${mathBlocks.length - 1}END`;
            });

            // Protect inline math $...$
            protectedText = protectedText.replace(/\$([^$\n]+?)\$/g, (match, tex) => {
                mathBlocks.push({ type: 'inline', tex: tex });
                return `MATHINLINE${mathBlocks.length - 1}END`;
            });

            // Protect inline math \(...\)
            protectedText = protectedText.replace(/\\\(([\s\S]*?)\\\)/g, (match, tex) => {
                mathBlocks.push({ type: 'inline', tex: tex });
                return `MATHINLINE${mathBlocks.length - 1}END`;
            });

            // Parse Markdown
            let html = marked.parse(protectedText);

            // Wrap tables for horizontal scrolling
            html = html.replace(/<table>/g, '<div style="overflow-x: auto; margin-bottom: 16px;"><table class="interactive-table">').replace(/<\/table>/g, '</table></div>');

            // Fix: Restore raw TeX inside Mermaid blocks BEFORE rendering KaTeX
            // This prevents KaTeX HTML from breaking Mermaid diagrams
            html = html.replace(/<div class="mermaid">([\s\S]*?)<\/div>/g, (match, content) => {
                // 1. Restore math (sanitized)
                let processed = content.replace(/MATH(BLOCK|INLINE)(\d+)END/g, (m, type, idx) => {
                    const block = mathBlocks[parseInt(idx)];
                    if (block) {
                        // Sanitize: remove newlines and problematic chars that break Mermaid syntax
                        let clean = block.tex.replace(/\n/g, ' ').trim();
                        clean = clean.replace(/[\(\)\[\]\{\}"']/g, ''); 
                        return clean;
                    }
                    return m;
                });

                // 2. Decode HTML entities that Marked might have escaped
                processed = processed
                    .replace(/&gt;/g, '>')
                    .replace(/&lt;/g, '<')
                    .replace(/&amp;/g, '&')
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'");

                // 3. Remove chatty lines (References, Notes) that break syntax
                processed = processed.replace(/^\s*[\(]?(Reference|Note|Source):.*$/gim, '');

                // 4. Robustly fix Mermaid node labels
                // Strategy: Protect valid quoted labels, then quote any unquoted labels containing special chars.
                
                const placeholders = [];
                
                // Helper to protect already quoted strings inside delimiters
                // Matches: delimiter "..." delimiter
                // We use a generic regex that looks for quoted strings inside common shape delimiters
                // This is a simplification but covers most cases like ["..."] or ("...")
                processed = processed.replace(/(\[\[|\[\(|\[|{{|\(\(|\(|\{)(\s*"((?:[^"\\]|\\.)*)"\s*)(\]\]|\)\]|\]|}}|\)\)|\)|})/g, (match) => {
                    placeholders.push(match);
                    return `@@MERMAID_PH_${placeholders.length - 1}@@`;
                });

                // Helper function to quote content if needed
                const quoteIfNeeded = (content, start, end) => {
                    // If content is already fully quoted (starts and ends with "), strip quotes and re-process
                    if (content.startsWith('"') && content.endsWith('"') && content.length >= 2) {
                        return `${start}${content}${end}`;
                    }

                    // ALWAYS quote if it's not a simple alphanumeric string
                    if (!/^[a-zA-Z0-9_]+$/.test(content)) {
                        const escaped = content
                            .replace(/\\/g, '\\\\')
                            .replace(/"/g, '\\"');
                        return `${start}"${escaped}"${end}`;
                    }
                    return `${start}${content}${end}`;
                };

                // Fix unquoted subgraph titles
                processed = processed.replace(/^(\s*)subgraph\s+([^"\[\r\n]+)(?:\r?\n|$)/gm, (match, indent, content) => {
                    const trimmed = content.trim();
                    return `${indent}subgraph "${trimmed}"\n`;
                });

                // Combined regex for all node shapes to avoid double-processing nested content
                // Order matters: specific delimiters must come before generic ones (e.g. [( before [)
                const nodeRegex = /\[\[(?:(?!\]\]).)*\]\]|\[\((?:(?!\)\]).)*\)\]|\(\((?:(?!\)\)).)*\)\)|\(\[(?:(?!\]\)).)*\]\)|{{(?:(?!}}).)*}}|\[(?:[^\[\]]|\[[^\[\]]*\])*\]|\((?:[^()]*|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\}/g;

                processed = processed.replace(nodeRegex, (match) => {
                    let content = '';
                    let start = '';
                    let end = '';

                    if (match.startsWith('[[') && match.endsWith(']]')) {
                        start = '[['; end = ']]';
                        content = match.slice(2, -2);
                    } else if (match.startsWith('[(') && match.endsWith(')]')) {
                        start = '[('; end = ')]';
                        content = match.slice(2, -2);
                    } else if (match.startsWith('((') && match.endsWith('))')) {
                        start = '(('; end = '))';
                        content = match.slice(2, -2);
                    } else if (match.startsWith('([') && match.endsWith('])')) {
                        start = '(['; end = '])';
                        content = match.slice(2, -2);
                    } else if (match.startsWith('{{') && match.endsWith('}}')) {
                        start = '{{'; end = '}}';
                        content = match.slice(2, -2);
                    } else if (match.startsWith('[') && match.endsWith(']')) {
                        start = '['; end = ']';
                        content = match.slice(1, -1);
                    } else if (match.startsWith('(') && match.endsWith(')')) {
                        start = '('; end = ')';
                        content = match.slice(1, -1);
                    } else if (match.startsWith('{') && match.endsWith('}')) {
                        start = '{'; end = '}';
                        content = match.slice(1, -1);
                    } else {
                        return match;
                    }

                    return quoteIfNeeded(content, start, end);
                });

                // Restore placeholders
                processed = processed.replace(/@@MERMAID_PH_(\d+)@@/g, (match, idx) => {
                    return placeholders[parseInt(idx)] || match;
                });

                // Escape HTML tags so they survive into textContent
                const escapeHtml = (str) => str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');

                return `<div class="mermaid" data-original="${encodeURIComponent(content)}">${escapeHtml(processed)}</div>`;
            });

            // Restore and render math for the rest of the document
            html = html.replace(/MATHBLOCK(\d+)END/g, (match, index) => {
                const block = mathBlocks[parseInt(index)];
                try {
                    return katex.renderToString(block.tex, { displayMode: true, throwOnError: false });
                } catch (e) {
                    return match;
                }
            });

            html = html.replace(/MATHINLINE(\d+)END/g, (match, index) => {
                const block = mathBlocks[parseInt(index)];
                try {
                    return katex.renderToString(block.tex, { displayMode: false, throwOnError: false });
                } catch (e) {
                    return match;
                }
            });

            return html;
        }

        async function runMermaid(container) {
            if (!window.mermaid) return;
            const nodes = container.querySelectorAll('.mermaid');
            for (const node of nodes) {
                const original = node.getAttribute('data-original');
                const codeToRender = node.textContent;
                
                try {
                    // Validate first
                    await window.mermaid.parse(codeToRender);
                    // If valid, run
                    await window.mermaid.run({ nodes: [node] });

                    // Add double-click listener to enlarge
                    node.style.cursor = 'pointer';
                    node.title = 'Double-click to enlarge';
                    node.ondblclick = (e) => {
                        e.stopPropagation();
                        openImageModal(node.innerHTML);
                    };
                } catch (err) {
                    console.warn('Mermaid validation/render failed:', err);
                    // Fallback to raw code
                    const rawCode = original ? decodeURIComponent(original) : codeToRender;
                    
                    const pre = document.createElement('pre');
                    const code = document.createElement('code');
                    code.className = 'hljs language-mermaid'; 
                    code.textContent = rawCode;
                    pre.appendChild(code);
                    
                    // Add a small error message above
                    const errorMsg = document.createElement('div');
                    errorMsg.style.color = '#b00020';
                    errorMsg.style.fontSize = '12px';
                    errorMsg.style.marginBottom = '4px';
                    errorMsg.textContent = 'Diagram syntax error (showing raw):';

                    // Debug: Show what we TRIED to render if it's different from raw
                    if (codeToRender !== rawCode) {
                        const debugMsg = document.createElement('div');
                        debugMsg.style.color = '#666';
                        debugMsg.style.fontSize = '11px';
                        debugMsg.style.marginTop = '4px';
                        debugMsg.style.whiteSpace = 'pre-wrap';
                        debugMsg.textContent = 'Processed code that failed:\n' + codeToRender;
                        pre.appendChild(debugMsg);
                    }
                    
                    const wrapper = document.createElement('div');
                    wrapper.appendChild(errorMsg);
                    wrapper.appendChild(pre);
                    
                    node.replaceWith(wrapper);
                    
                    if (window.hljs) window.hljs.highlightElement(code);
                }
            }
        }

        async function sendMessage() {
            if (isLoading || isIndexing) return;
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            isLoading = true;
            updateInputState();
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            adjustHeight(); // Reset height
            
            // Show loading indicator and create placeholder for streaming response
            const chatContainer = document.getElementById('chatContainer');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.textContent = 'Thinking...';
            loadingDiv.id = 'loading';
            chatContainer.appendChild(loadingDiv);
            if (autoScroll) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            
            // Create assistant message div for streaming
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant';
            messageDiv.id = 'streaming-message';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-button';
            copyBtn.type = 'button';
            copyBtn.textContent = '‚ßâ';
            copyBtn.title = 'Copy response';
            copyBtn.onclick = () => copyAssistantMessage(messageDiv);
            messageDiv.appendChild(copyBtn);

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.id = 'streaming-content';
            messageDiv.appendChild(contentDiv);
            
            try {
                // Prefer EventSource (GET SSE) for reliable streaming
                const params = new URLSearchParams();
                params.set('message', message);
                if (sessionId) params.set('session_id', sessionId);
                if (selectedPaperId) params.set('paper_id', selectedPaperId);

                const sseUrl = `${API_URL}/chat/stream?${params.toString()}`;

                // Remove loading indicator and add streaming container
                document.getElementById('loading').remove();
                chatContainer.appendChild(messageDiv);

                const es = new EventSource(sseUrl);
                let fullText = '';
                isStreaming = true;

                es.onmessage = async (evt) => {
                    try {
                        const data = JSON.parse(evt.data);
                        if (data.type === 'session') {
                            const newId = data.session_id;
                            if (sessionId !== newId) {
                                sessionId = newId;
                                updateActiveSessionLabel(null, sessionId);
                            }
                            try {
                                window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                            } catch (e) {
                                console.warn('Could not persist last session id', e);
                            }
                            // Persist the current sidebar paper set as the
                            // initial context for this session so the backend
                            // and AI agent see exactly the same papers.
                            // If the user uploaded papers in this window
                            // before sending the first message, currentPaperIds
                            // already reflects those, so the very first
                            // response will be correctly scoped.
                            await saveSessionContext({ reload: false });
                            return;
                        }
                        if (data.type === 'session_created') {
                            // Backend created a new session - refresh sessions sidebar
                            const sessionsSidebar = document.getElementById('sessionsSidebar');
                            if (sessionsSidebar && !sessionsSidebar.classList.contains('collapsed')) {
                                await loadSessionsList();
                            }
                            return;
                        }
                        if (data.type === 'image') {
                            // Render generated image inline
                            const img = document.createElement('img');
                            img.src = data.data_url;
                            img.alt = 'Generated visualization';
                            img.style.maxWidth = '100%';
                            img.style.borderRadius = '8px';
                            img.style.display = 'block';
                            img.style.marginBottom = '8px';
                            messageDiv.insertBefore(img, contentDiv);
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                            return;
                        }
                        if (data.type === 'chunk') {
                            fullText += data.text;
                            if (typeof marked !== 'undefined') {
                                contentDiv.innerHTML = renderMarkdownWithMath(fullText);
                                attachCodeBlockCopyButtons(contentDiv);
                            } else {
                                contentDiv.textContent = fullText;
                            }
                            if (autoScroll) {
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                            return;
                        }
                        if (data.type === 'done') {
                            const sourcePapers = data.source_papers || [];
                            if (sourcePapers.length > 0) {
                                const sourcesDiv = document.createElement('div');
                                sourcesDiv.className = 'message-sources';
                                sourcesDiv.textContent = `Sources: ${sourcePapers.join(', ')}`;
                                messageDiv.appendChild(sourcesDiv);
                            }
                            if (data.token_usage) {
                                await updateTokenStats();
                            }

                            // Render mermaid diagrams in the final message
                            await runMermaid(contentDiv);
                            makeTablesInteractive(contentDiv);

                            // Ensure latest paper context is persisted with the session
                            await saveSessionContext({ reload: false });
                            
                            es.close();
                            isStreaming = false;
                            isLoading = false;
                            adjustHeight();
                            input.focus();
                            // Remove streaming IDs
                            messageDiv.removeAttribute('id');
                            contentDiv.removeAttribute('id');
                        }
                        if (data.type === 'error') {
                            const msg = data.message || 'Server error';
                            // Preserve any streamed content and append a
                            // warning instead of overwriting the answer.
                            const errDiv = document.createElement('div');
                            errDiv.style.marginTop = '8px';
                            errDiv.style.fontSize = '12px';
                            errDiv.style.color = '#b00020';
                            errDiv.textContent = 'Warning: ' + msg;
                            messageDiv.appendChild(errDiv);
                            es.close();
                            isStreaming = false;
                            isLoading = false;
                            adjustHeight();
                            input.focus();
                            return;
                        }
                    } catch (e) {
                        console.error('SSE parse error', e);
                    }
                };

                es.onerror = () => {
                    // Stream ended or failed; UI already shows any error
                    es.close();
                    isStreaming = false;
                    isLoading = false;
                    adjustHeight();
                    input.focus();
                };

            } catch (error) {
                console.error('Error sending message:', error);
                const loadingElem = document.getElementById('loading');
                if (loadingElem) {
                    loadingElem.textContent = 'Error: Could not get response';
                } else {
                    addMessage('Error: Could not get response', 'assistant');
                }
                
                // Remove streaming message if it exists
                const streamingMsg = document.getElementById('streaming-message');
                if (streamingMsg) streamingMsg.remove();
                isStreaming = false;
                isLoading = false;
                adjustHeight();
                input.focus();
            }
        }

        function addMessage(content, role, sources = [], messageId = null) {
            const chatContainer = document.getElementById('chatContainer');
            
            // Remove empty state if exists
            const emptyState = chatContainer.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            if (messageId) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'message-delete-btn';
                deleteBtn.type = 'button';
                deleteBtn.textContent = 'üóë';
                deleteBtn.title = 'Delete message';
                deleteBtn.onclick = () => deleteMessage(messageId, messageDiv);
                messageDiv.appendChild(deleteBtn);
            }

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-button';
            copyBtn.type = 'button';
            copyBtn.textContent = '‚ßâ';
            copyBtn.title = 'Copy message';
            copyBtn.onclick = () => copyAssistantMessage(messageDiv, content);
            messageDiv.appendChild(copyBtn);

            // Create content div
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // For assistant messages, parse markdown
            if (role === 'assistant' && typeof marked !== 'undefined') {
                contentDiv.innerHTML = renderMarkdownWithMath(content);
                attachCodeBlockCopyButtons(contentDiv);
                makeTablesInteractive(contentDiv);
                
                // Render mermaid diagrams if any
                setTimeout(() => {
                    runMermaid(contentDiv);
                }, 100);
            } else {
                // For user messages, use plain text
                contentDiv.textContent = content;
            }
            
            messageDiv.appendChild(contentDiv);
            
            if (sources && sources.length > 0) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.className = 'message-sources';
                sourcesDiv.textContent = `Sources: ${sources.join(', ')}`;
                messageDiv.appendChild(sourcesDiv);
            }
            
            chatContainer.appendChild(messageDiv);
            if (autoScroll) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        async function copyAssistantMessage(messageElement, fallbackText) {
            try {
                const contentEl = messageElement.querySelector('.message-content');
                let textToCopy = fallbackText || '';

                if (!textToCopy && contentEl) {
                    // Prefer the underlying markdown/text, but fall back to visible text
                    textToCopy = contentEl.textContent || '';
                }

                if (!textToCopy) return;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = textToCopy;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }

                const btn = messageElement.querySelector('.copy-button');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = '‚úì';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = original;
                        btn.classList.remove('copied');
                    }, 1200);
                }
            } catch (e) {
                console.error('Copy failed', e);
            }
        }

        function attachCodeBlockCopyButtons(container) {
            const blocks = container.querySelectorAll('pre > code');
            blocks.forEach((codeEl) => {
                const pre = codeEl.parentElement;
                if (!pre || pre.querySelector('.code-copy-button')) {
                    return;
                }

                const btn = document.createElement('button');
                btn.className = 'code-copy-button';
                btn.type = 'button';
                btn.textContent = 'Copy';
                btn.title = 'Copy code';
                btn.onclick = async (e) => {
                    e.stopPropagation();
                    const text = codeEl.textContent || '';
                    if (!text) return;

                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(text);
                        } else {
                            const textarea = document.createElement('textarea');
                            textarea.value = text;
                            textarea.style.position = 'fixed';
                            textarea.style.opacity = '0';
                            document.body.appendChild(textarea);
                            textarea.focus();
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                        }

                        btn.classList.add('copied');
                        const original = btn.textContent;
                        btn.textContent = 'Copied';
                        setTimeout(() => {
                            btn.textContent = original;
                            btn.classList.remove('copied');
                        }, 1200);
                    } catch (err) {
                        console.error('Code block copy failed', err);
                    }
                };

                pre.appendChild(btn);
            });
        }

        function scrollToBottom() {
            const chatContainer = document.getElementById('chatContainer');
            autoScroll = true;
            chatContainer.scrollTop = chatContainer.scrollHeight;
            const scrollBtnEl = document.getElementById('scrollToBottomButton');
            scrollBtnEl.style.display = 'none';
        }

        async function showSessions() {
            // Deprecated - now using sidebar
            toggleSessionsSidebar();
        }

        async function loadSessionsList() {
            try {
                const url = `${API_URL}/chat/sessions`;
                const res = await fetch(url);
                const data = await res.json();
                const sessions = data.sessions || [];
                
                const sessionsList = document.getElementById('sessionsList');
                
                if (!sessions.length) {
                    sessionsList.innerHTML = '<div class="empty-state" style="padding: 20px; text-align: center; color: #999; font-size: 13px;">No saved sessions</div>';
                    return;
                }

                sessionsList.innerHTML = sessions.map(s => {
                    const isActive = s.session_id === sessionId;
                    const shortId = s.session_id.slice(0, 8);
                    const date = new Date(s.updated_at);
                    const timeStr = date.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    const displayName = s.session_name || `Session ${shortId}...`;
                    
                    return `
                        <div class="session-item ${isActive ? 'active' : ''}" onclick="switchToSession('${s.session_id}')">
                            <div class="session-info">
                                <span class="session-id-label" 
                                      title="Click to rename" 
                                      ondblclick="event.stopPropagation(); renameSession('${s.session_id}', this)"
                                      style="cursor: pointer; font-weight: 500; font-size: 13px; color: #333; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block;">${displayName}</span>
                                <button 
                                    class="session-delete-btn" 
                                    onclick="event.stopPropagation(); deleteSessionById('${s.session_id}')"
                                    title="Delete session"
                                >‚úï</button>
                            </div>
                            <div class="session-meta">
                                ${s.message_count || 0} messages ‚Ä¢ ${s.total_tokens || 0} tokens
                            </div>
                            <div class="session-meta">
                                ${timeStr}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                console.error('Failed to list sessions', err);
            }
        }

        async function switchToSession(id) {
            if (id === sessionId) return; // Already active
            await loadSession(id);
            // Refresh the sessions list to update active state
            await loadSessionsList();
        }

        async function deleteSessionById(id) {
            if (!confirm('Delete this session?')) return;
            
            try {
                await fetch(`${API_URL}/chat/session/${id}`, { method: 'DELETE' });
                
                // If we deleted the active session, create a new one
                if (id === sessionId) {
                    await newSession();
                }
                
                // Refresh the sessions list
                await loadSessionsList();
            } catch (e) {
                console.error('Failed to delete session', e);
            }
        }

        async function renameSession(sessionIdToRename, element) {
            const currentName = element.textContent.trim();
            const newName = window.prompt('Enter new session name:', currentName);
            
            if (newName === null || newName.trim() === '') {
                return; // User cancelled or empty name
            }
            
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionIdToRename}/name`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_name: newName.trim() }),
                });
                
                if (res.ok) {
                    // Refresh the sessions list to show updated name
                    await loadSessionsList();
                    if (sessionIdToRename === sessionId) {
                        updateActiveSessionLabel(newName.trim(), sessionId);
                    }
                } else {
                    alert('Failed to rename session');
                }
            } catch (e) {
                console.error('Failed to rename session', e);
                alert('Error renaming session');
                       }
        }

        function updateChatBackground() {
            const chatContainer = document.getElementById('chatContainer');
            if (selectedPaperId) {
                chatContainer.classList.add('specialized');
            } else {
                chatContainer.classList.remove('specialized');
            }
        }

        function updateNotesButtonState() {
            const btn = document.getElementById('notesButton');
            if (!btn) return;
            
            if (currentNotes && currentNotes.trim().length > 0) {
                btn.classList.add('has-notes');
                btn.textContent = 'üìù Notes ‚Ä¢';
            } else {
                btn.classList.remove('has-notes');
                btn.textContent = 'üìù Notes';
            }
        }

        async function loadSession(id) {
            try {
                const res = await fetch(`${API_URL}/chat/session/${id}`);
                if (!res.ok) {
                    alert('Session not found');
                    return;
                }
                const conversation = await res.json();

                sessionId = conversation.session_id;
                currentNotes = conversation.notes || '';
                updateNotesButtonState();

                updateActiveSessionLabel(conversation.session_name, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                const messages = conversation.messages || [];
                const selected = conversation.selected_paper_id || null;
                const sessionPaperIds = conversation.paper_ids || [];

                // Refresh papers list scoped to this session's paper_ids
                await loadPapers(sessionPaperIds);

                // Restore selected paper in UI if it still exists
                selectedPaperId = selected && sessionPaperIds.includes(selected) ? selected : null;
                document.querySelectorAll('.paper-item').forEach(item => {
                    if (selectedPaperId && item.dataset.paperId === selectedPaperId) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });

                // Re-render chat history
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '';
                for (const msg of messages) {
                    const role = msg.role === 'assistant' ? 'assistant' : 'user';
                    addMessage(msg.content, role, msg.source_papers || [], msg.id);
                }

                updateChatBackground();
                await updateTokenStats();

                // Ensure we are scrolled to the latest message after reload
                try {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                } catch {}
            } catch (err) {
                console.error('Failed to load session', err);
                alert('Error loading session');
            }
        }

        async function clearChat() {
            if (!sessionId) {
                // No session, just clear UI
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
                autoScroll = true;
                return;
            }

            try {
                // Clear messages from backend
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/clear`, {
                    method: 'POST',
                });
                
                if (!res.ok) {
                    console.error('Failed to clear chat history');
                    return;
                }
                
                // Clear UI
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
                autoScroll = true;
                
                // Update token stats
                await updateTokenStats();
            } catch (e) {
                console.error('Error clearing chat', e);
            }
        }

        async function newSession() {
            const chatContainer = document.getElementById('chatContainer');
            
            // Delete current session if it has no messages (papers don't matter)
            if (sessionId) {
                try {
                    const conv = await fetch(`${API_URL}/chat/session/${sessionId}`);
                    if (conv.ok) {
                        const data = await conv.json();
                        const messages = data.messages || [];
                        
                        // Delete if no messages
                        if (messages.length === 0) {
                            await fetch(`${API_URL}/chat/session/${sessionId}`, { method: 'DELETE' });
                        }
                    }
                } catch (e) {
                    console.warn('Could not check/delete empty session', e);
                }
            }
            
            // Clear UI
            chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
            autoScroll = true;

            // Create a brand new backend session with empty paper_ids
            try {
                const res = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                if (!res.ok) {
                    console.error('Failed to create new chat session');
                    return;
                }
                
                const data = await res.json();
                sessionId = data.session_id;
                updateActiveSessionLabel(null, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                
                // Clear local state before saving to backend
                currentPaperIds = [];
                selectedPaperId = null;
                currentNotes = '';
                updateNotesButtonState();
                
                // Persist empty paper context and reload session from backend
                await saveSessionContext();
                
                // UI now follows backend: loadSession will refresh sidebar from backend state
                await loadSession(sessionId);
                
                // Refresh sessions sidebar if open
                const sessionsSidebar = document.getElementById('sessionsSidebar');
                if (!sessionsSidebar.classList.contains('collapsed')) {
                    await loadSessionsList();
                }
            } catch (e) {
                console.error('Error creating new session', e);
            }
        }

        async function deleteSession() {
            if (!sessionId) {
                // Nothing to delete; just create a new empty session
                await newSession();
                return;
            }

            try {
                // Delete current session from backend
                await fetch(`${API_URL}/chat/session/${sessionId}`, { method: 'DELETE' });
            } catch (e) {
                console.error('Error deleting session', e);
           
            }

            // Create a fresh empty session and reload from backend
            try {
                const createRes = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                if (createRes.ok) {
                    const data = await createRes.json();
                    sessionId = data.session_id;
                    updateActiveSessionLabel(null, sessionId);
                    try {
                        window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                    } catch (e) {
                        console.warn('Could not persist last session id', e);
                    }
                    
                    // Clear local state before saving
                    currentPaperIds = [];
                    selectedPaperId = null;
                    currentNotes = '';
                    updateNotesButtonState();
                    
                    // Save empty context and reload UI from backend
                    await saveSessionContext();
                    await loadSession(sessionId);
                    
                    // Refresh sessions sidebar if open
                    const sessionsSidebar = document.getElementById('sessionsSidebar');
                    if (!sessionsSidebar.classList.contains('collapsed')) {
                        await loadSessionsList();
                    }
                } else {
                    console.error('Failed to create new session after delete');
                }
            } catch (e) {
                console.error('Error creating new session after delete', e);
            }
        }

        async function resetAllData() {
            const confirmed = window.confirm('This will delete ALL papers, vector DB, conversations, and metadata. This cannot be undone.\n\nAre you sure?');
            if (!confirmed) return;

            try {
                const res = await fetch(`${API_URL}/admin/reset`, { method: 'POST' });
                if (!res.ok) {
                    alert('Failed to reset data');
                    return;
                }

                // After reset, clear local state and reload page for a clean start.
                try {
                    window.sessionStorage.removeItem(LAST_SESSION_KEY);
                } catch (_) {}

                alert('All data has been reset. The page will reload.');
                window.location.reload();
            } catch (e) {
                console.error('Failed to reset all data', e);
                alert('Error resetting data');
            }
        }

        async function pruneData() {
            const confirmed = window.confirm('This will delete all papers that are NOT used in any saved session.\n\nAre you sure?');
            if (!confirmed) return;

            try {
                const res = await fetch(`${API_URL}/admin/prune`, { method: 'POST' });
                if (!res.ok) {
                    alert('Failed to prune data');
                    return;
                }
                const data = await res.json();
                alert(data.message);
                
                // Reload papers list to reflect changes
                if (sessionId) {
                    await loadSession(sessionId);
                } else {
                    // Reload all papers (pass null/undefined to show all)
                    await loadPapers();
                }
            } catch (e) {
                console.error('Failed to prune data', e);
                alert('Error pruning data');
            }
        }

        async function removePaperFromSession(paperId) {
            if (!sessionId) return;
            
            try {
                // Fetch current session state from backend
                const res = await fetch(`${API_URL}/chat/session/${sessionId}`);
                if (!res.ok) return;
                
                const data = await res.json();
                const currentPapers = data.paper_ids || [];
                
                // Remove paper from backend state
                const updatedPapers = currentPapers.filter(id => id !== paperId);
                const updatedSelected = data.selected_paper_id === paperId ? null : data.selected_paper_id;
                
                // Update backend first
                const updateRes = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: updatedSelected,
                        paper_ids: updatedPapers,
                    }),
                });
                
                if (updateRes.ok) {
                    // Backend updated successfully, now reload UI from backend
                    await loadSession(sessionId);
                }
            } catch (err) {
                console.error('Failed to remove paper from session', err);
            }
        }

        function updateActiveSessionLabel(name, id) {
            const baseTitle = 'Journal Article AI Assistant';

            if (!id) {
                document.title = baseTitle;
                return;
            }
            
            if (name) {
                document.title = `${name} - ${baseTitle}`;
            } else {
                const shortId = String(id).slice(0, 8);
                document.title = `Session ${shortId} - ${baseTitle}`;
            }
        }

        async function saveSessionContext(opts = {}) {
            if (!sessionId) return;
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: selectedPaperId,
                        paper_ids: currentPaperIds,
                    }),
                });

                if (res.ok) {
                    // After saving, reload the full session from the
                    // backend so the sidebar and local state always
                    // reflect the canonical session context (paper_ids
                    // and selected_paper_id).
                    const shouldReload = opts.reload !== false;
                    if (shouldReload && !isStreaming) {
                        await loadSession(sessionId);
                    }
                }
            } catch (err) {
                console.error('Failed to save session context', err);
            }
        }

        async function updateTokenStats() {
            // Token stats are shown in the sidebar, so refresh the list to update them
            if (sessionId) {
                await loadSessionsList();
            }
        }

        // Auto-resume a previous session on page load; if none exists,
        // create a new empty session just like a first-time launch.
        window.addEventListener('load', async () => {
            try {
                // Load sessions list on page load
                await loadSessionsList();
                
                const lastId = window.sessionStorage.getItem(LAST_SESSION_KEY);
                if (lastId) {
                    const res = await fetch(`${API_URL}/chat/session/${lastId}`);
                    if (res.ok) {
                        await loadSession(lastId);
                        // updateActiveSessionLabel is handled by loadSession
                        return;
                    }
                    // Session no longer exists; clear stored id
                    window.sessionStorage.removeItem(LAST_SESSION_KEY);
                }

                // No valid previous session: create a brand new session
                // so the behavior matches a fresh app launch.
                const createRes = await fetch(`${API_URL}/chat/session`, {
                    method: 'POST',
                });
                if (!createRes.ok) {
                    console.warn('Failed to create initial session');
                    updateActiveSessionLabel(null, null);
                    return;
                }
                const created = await createRes.json();
                sessionId = created.session_id;
                updateActiveSessionLabel(null, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                // Persist empty paper context and sync UI from backend
                await saveSessionContext();
                // Refresh sessions list after creating new session
                await loadSessionsList();
            } catch (e) {
                console.warn('Failed to initialize session on load', e);
            }
        });

        async function duplicateSession() {
            if (!sessionId) {
                alert("No active session to duplicate.");
                return;
            }
            
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/duplicate`, {
                    method: 'POST'
                });
                
                if (res.ok) {
                    const data = await res.json();
                    // Switch to the new session
                    await switchToSession(data.session_id);
                } else {
                    alert("Failed to duplicate session");
                }
            } catch (e) {
                console.error("Error duplicating session", e);
                alert("Error duplicating session");
            }
        }

        function initProgressStream() {
            const evtSource = new EventSource(`${API_URL}/progress`);
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            const status = document.getElementById('progressStatus');
            const percent = document.getElementById('progressPercent');

            evtSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.status === 'processing') {
                        container.style.display = 'block';
                        const pct = Math.round(data.progress || 0);
                        bar.style.width = `${pct}%`;
                        status.textContent = data.message || 'Processing...';
                        percent.textContent = `${pct}%`;
                    } else if (data.status === 'completed') {
                        bar.style.width = '100%';
                        percent.textContent = '100%';
                        status.textContent = 'Done!';
                        
                        // Refresh papers list if we just finished indexing
                        if (sessionId) {
                            loadSession(sessionId);
                        } else {
                            loadPapers();
                        }

                        setTimeout(() => {
                            container.style.display = 'none';
                            bar.style.width = '0%';
                        }, 3000);
                    } else if (data.status === 'error') {
                        status.textContent = 'Error: ' + (data.message || 'Unknown error');
                        status.style.color = '#b00020';
                        setTimeout(() => {
                            container.style.display = 'none';
                            status.style.color = '';
                        }, 5000);
                    }
                } catch (e) {
                    console.error('Error parsing progress event', e);
                }
            };
            
            evtSource.onerror = function(err) {
                // EventSource will try to reconnect automatically
                // We can just log it for debugging
                // console.debug("Progress stream connection lost, reconnecting...", err);
            };
        }

        // Initialize progress stream
        initProgressStream();

        async function deleteMessage(messageId, element) {
            if (!confirm('Delete this message?')) return;
            
            try {
                const res = await fetch(`${API_URL}/chat/message/${messageId}`, {
                    method: 'DELETE'
                });
                
                if (res.ok) {
                    element.remove();
                    // If no messages left, show empty state
                    const chatContainer = document.getElementById('chatContainer');
                    if (chatContainer.children.length === 0) {
                         chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
                    }
                    // Update token stats as deleting a message changes the context size
                    await updateTokenStats();
                } else {
                    alert('Failed to delete message');
                }
            } catch (e) {
                console.error('Error deleting message', e);
                alert('Error deleting message');
            }
        }

        function openNotes() {
            if (!sessionId) {
                alert('Please create or select a session first.');
                return;
            }
            const modal = document.getElementById('notesModal');
            const textarea = document.getElementById('sessionNotes');
            textarea.value = currentNotes || '';
            modal.style.display = 'flex';
            textarea.focus();
        }

        function closeNotes() {
            document.getElementById('notesModal').style.display = 'none';
        }

        async function saveNotes() {
            if (!sessionId) return;
            
            const textarea = document.getElementById('sessionNotes');
            const newNotes = textarea.value;
            const btn = document.querySelector('#notesModal .index-button:not(.secondary)');
            const originalText = btn.textContent;
            
            btn.textContent = 'Saving...';
            btn.disabled = true;

            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/notes`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ notes: newNotes }),
                });

                if (res.ok) {
                    currentNotes = newNotes;
                    updateNotesButtonState();
                    btn.textContent = 'Saved!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                        closeNotes();
                    }, 1000);
                } else {
                    throw new Error('Failed to save notes');
                }
            } catch (e) {
                console.error('Error saving notes', e);
                btn.textContent = 'Error';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        function closeImageModal() {
            if (panZoomInstance) {
                panZoomInstance.destroy();
                panZoomInstance = null;
            }
            document.getElementById('imageModal').style.display = 'none';
            document.getElementById('imageModalBody').innerHTML = '';
        }

        function openImageModal(htmlContent) {
            const modal = document.getElementById('imageModal');
            const body = document.getElementById('imageModalBody');
            body.innerHTML = htmlContent;
            
            // Ensure SVG scales to fit but maintains aspect ratio
            const svg = body.querySelector('svg');
            if (svg) {
                // Remove fixed dimensions to allow scaling
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.maxWidth = 'none';
                svg.style.maxHeight = 'none';
                
                // Initialize pan-zoom
                // We need a small timeout to ensure the modal is visible and layout is computed
                modal.style.display = 'flex';
                
                setTimeout(() => {
                    try {
                        panZoomInstance = svgPanZoom(svg, {
                            zoomEnabled: true,
                            controlIconsEnabled: true,
                            fit: true,
                            center: true,
                            minZoom: 0.1,
                            maxZoom: 10
                        });
                    } catch (e) {
                        console.warn('Failed to initialize svg-pan-zoom', e);
                    }
                }, 50);
            } else {
                modal.style.display = 'flex';
            }
        }
    </script>
</body>
</html>
