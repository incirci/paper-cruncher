<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journal Article AI Assistant</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            display: flex;
            background: #f5f5f5;
            overflow-x: hidden;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s;
        }

        .sidebar.collapsed {
            margin-left: -300px;
        }

        .sessions-sidebar {
            width: 280px;
            background: white;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: margin-right 0.3s;
        }

        .sessions-sidebar.collapsed {
            margin-right: -280px;
        }

        .sessions-header {
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sessions-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .sessions-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .session-item {
            padding: 12px;
            margin-bottom: 6px;
            background: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 2px solid transparent;
        }

        .session-item:hover {
            background: #f0f0f0;
        }

        .session-item.active {
            background: #e3f2fd;
            border-color: #007bff;
        }

        .session-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 4px;
        }

        .session-id-label {
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #666;
        }

        .session-delete-btn {
            background: transparent;
            border: none;
            color: #b00020;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
            line-height: 1;
        }

        .session-delete-btn:hover {
            color: #8b0000;
        }

        .session-meta {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        .new-session-btn {
            width: 100%;
            padding: 10px;
            margin: 8px;
            margin-top: 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .new-session-btn:hover {
            background: #0056b3;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-direction: column;
            gap: 12px;
        }

        .sidebar-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .sidebar-header h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .index-button {
            width: 100%;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .index-button:hover {
            background: #0056b3;
        }

        .index-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .index-button.secondary {
            background: #6c757d;
        }

        .index-button.secondary:hover {
            background: #5a6268;
        }

        .progress-container {
            padding: 12px 20px;
            border-top: 1px solid #e0e0e0;
            background: #f9f9f9;
            display: none;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #555;
            margin-bottom: 6px;
        }

        .progress-track {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }

        .papers-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .paper-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f9f9f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 2px solid transparent;
        }

        .paper-item:hover {
            background: #f0f0f0;
        }

        .paper-item.selected {
            background: #e3f2fd;
            border-color: #007bff;
        }

        .paper-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .paper-meta {
            font-size: 12px;
            color: #666;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-sidebar {
            padding: 8px 16px;
            background: #f0f0f0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .toggle-sidebar:hover {
            background: #e0e0e0;
        }

        .danger-button {
            padding: 8px 16px;
            background: #dc3545;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 0 0 1px rgba(220, 53, 69, 0.4);
        }

        .danger-button:hover {
            background: #b02a37;
        }

        .stats {
            font-size: 14px;
            color: #666;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: relative;
            transition: background 0.3s ease;
        }

        .chat-container.specialized {
            background-color: #f8fbff;
            background-image: radial-gradient(#d0e0f0 1.5px, transparent 1.5px);
            background-size: 24px 24px;
        }

        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
            position: relative;
        }

        .message.user {
            align-self: flex-end;
            background: #007bff;
            color: white;
        }

        .message.assistant {
            align-self: flex-start;
            background: #f0f0f0;
            color: #333;
            white-space: pre-wrap;
        }

        .copy-button {
            position: absolute;
            top: 6px;
            right: 6px;
            background: #ffffffcc;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 6px;
            opacity: 0;
            transition: opacity 0.15s ease, background-color 0.15s ease;
        }

        .message.assistant:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background: #f3f3f3;
        }

        .copy-button.copied {
            background: #e6ffe6;
        }

        .message-content {
            line-height: 1.6;
        }

        .message-content h1,
        .message-content h2,
        .message-content h3 {
            margin-top: 16px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .message-content h1 {
            font-size: 1.5em;
        }

        .message-content h2 {
            font-size: 1.3em;
        }

        .message-content h3 {
            font-size: 1.1em;
        }

        .message-content p {
            margin-bottom: 12px;
        }

        .message-content ul,
        .message-content ol {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .message-content li {
            margin-bottom: 4px;
        }

        .message-content code {
            background: #e8e8e8;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .message-content pre {
            background: #2d2d2d;
            color: #f8f8f8;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 12px;
            position: relative;
        }

        .message-content pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        .code-copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ffffff33;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            padding: 2px 6px;
            color: #f8f8f8;
            opacity: 0;
            transition: opacity 0.15s ease, background-color 0.15s ease;
        }

        .message-content pre:hover .code-copy-button {
            opacity: 1;
        }

        .code-copy-button.copied {
            background: #4caf50;
            border-color: #4caf50;
        }

        .message-content blockquote {
            border-left: 4px solid #007bff;
            padding-left: 12px;
            margin-left: 0;
            margin-bottom: 12px;
            color: #666;
            font-style: italic;
        }

        .message-content strong {
            font-weight: 600;
        }

        .message-content em {
            font-style: italic;
        }

        .message-content a {
            color: #007bff;
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .message-content table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
        }

        .message-content th,
        .message-content td {
            border: 1px solid #ccc;
            padding: 6px 8px;
            text-align: left;
            font-size: 13px;
        }

        .message-content thead {
            background-color: #f5f5f5;
            font-weight: 600;
        }

        .message-sources {
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.8;
        }

        .input-container {
            padding: 24px;
            display: flex;
            justify-content: center;
            background: white;
        }

        .input-wrapper {
            position: relative;
            width: 100%;
            max-width: 768px;
            display: flex;
            align-items: flex-end;
            background: #f4f4f4;
            border-radius: 26px;
            padding: 10px;
            border: 1px solid transparent;
            transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
        }

        .input-wrapper:focus-within {
            border-color: #d9d9d9;
            background: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .input-box {
            flex: 1;
            padding: 4px 8px;
            padding-right: 40px;
            border: none;
            background: transparent;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .input-box:focus {
            outline: none;
        }

        .send-button {
            position: absolute;
            right: 8px;
            bottom: 8px;
            width: 32px;
            height: 32px;
            background: #e5e5e5;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: default;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .send-button.active {
            background: #007bff;
            cursor: pointer;
        }

        .send-button.active:hover {
            background: #0056b3;
        }

        .send-button svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        .loading {
            padding: 12px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .scroll-to-bottom {
            position: fixed;
            right: 24px;
            bottom: 96px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid #ddd;
            background: #ffffffee;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
            display: none;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .scroll-to-bottom span {
            font-size: 14px;
        }

        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title-row">
                <h2>Papers</h2>
                <span id="paperCount">0</span>
            </div>
            <input 
                type="file" 
                id="paperUploadInput" 
                accept="application/pdf" 
                multiple 
                style="display:none" 
            >
            <button class="index-button secondary" id="uploadButton" onclick="triggerPaperUpload()" style="width: 100%;">
                ‚¨ÜÔ∏è Upload PDFs
            </button>
            <div style="display: flex; gap: 8px; width: 100%;">
                <button class="index-button secondary" id="mindmapButton" onclick="openMindmap()" style="flex: 1;">
                    üß† View Mindmap
                </button>
                <button class="index-button secondary" id="mindmapQueryButton" onclick="editMindmapQuery()" title="Edit mindmap instructions" style="width: 40px; padding: 0; display: flex; align-items: center; justify-content: center;">
                    ‚úèÔ∏è
                </button>
            </div>
        </div>
        
        <div id="progressContainer" class="progress-container">
            <div class="progress-header">
                <span id="progressStatus">Processing...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-track">
                <div id="progressBar" class="progress-fill"></div>
            </div>
        </div>

        <div class="papers-list" id="papersList">
            <div class="empty-state">Upload PDFs via the button or drop them here</div>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
            <div style="display: flex; gap: 12px; align-items: center;">
                <button class="toggle-sidebar" onclick="toggleSessionsSidebar()">üí¨ Sessions</button>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚ò∞ Papers</button>
            </div>
            <div class="stats">
                <button class="toggle-sidebar" style="margin-right: 12px;" onclick="clearChat()">üßπ Clear Chat</button>
                <button class="danger-button" onclick="resetAllData()">‚ö† Reset All Data</button>
            </div>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="empty-state">Ask a question about the papers</div>
        </div>
        <button class="scroll-to-bottom" id="scrollToBottomButton" onclick="scrollToBottom()">
            <span>‚Üì</span> New messages
        </button>

        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    class="input-box" 
                    id="messageInput" 
                    placeholder="Message Journal Assistant..."
                    rows="1"
                ></textarea>
                <button class="send-button" id="sendButton" onclick="sendMessage()" disabled>
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div class="sessions-sidebar" id="sessionsSidebar">
        <div class="sessions-header">
            <h3>üí¨ Sessions</h3>
            <button class="toggle-sidebar" style="padding: 4px 8px; font-size: 12px;" onclick="toggleSessionsSidebar()">‚úï</button>
        </div>
        <button class="new-session-btn" onclick="newSession()">Ôºã New Session</button>
        <button class="new-session-btn" onclick="duplicateSession()" style="background: #6c757d; margin-top: 0;">‚ùê Duplicate Session</button>
        <div class="sessions-list" id="sessionsList">
            <div class="empty-state" style="padding: 20px; text-align: center; color: #999; font-size: 13px;">No saved sessions</div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8000/api';
        let sessionId = null;
        let isLoading = false;
        let isIndexing = false;
        let isStreaming = false;
        let selectedPaperId = null; // Track selected paper ID
        let mindmapQuery = '';
        let lastMindmapQuery = '';
        let autoScroll = true;
        let currentPaperIds = [];
        let activeSessionLabel = '';

        const LAST_SESSION_KEY = 'paper_cruncher_last_session_id';

        // Wire up upload input
        document.getElementById('paperUploadInput').addEventListener('change', (e) => {
            const files = Array.from(e.target.files || []);
            if (!files.length) return;
            uploadPapers(files);
        });

        // Enable drag-and-drop on the papers list
        const papersListEl = document.getElementById('papersList');
        papersListEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            papersListEl.style.background = '#eef6ff';
        });
        papersListEl.addEventListener('dragleave', (e) => {
            e.preventDefault();
            papersListEl.style.background = '';
        });
        papersListEl.addEventListener('drop', (e) => {
            e.preventDefault();
            papersListEl.style.background = '';
            const files = Array.from(e.dataTransfer.files || []);
            if (!files.length) return;
            uploadPapers(files);
        });

        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');

        function updateInputState() {
            const hasContent = messageInput.value.trim().length > 0;
            const isBusy = isLoading || isIndexing;
            
            if (hasContent && !isBusy) {
                sendButton.disabled = false;
                sendButton.classList.add('active');
            } else {
                sendButton.disabled = true;
                sendButton.classList.remove('active');
            }

            if (isIndexing) {
                messageInput.disabled = true;
                messageInput.placeholder = "Indexing papers... please wait";
            } else if (isLoading) {
                // Keep input enabled but placeholder indicates busy
                messageInput.disabled = false;
                messageInput.placeholder = "Waiting for response...";
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = "Message Journal Assistant...";
            }
        }

        function adjustHeight() {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 200) + 'px';
            updateInputState();
        }

        messageInput.addEventListener('input', adjustHeight);

        // Handle Enter key (Shift+Enter for new line)
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendButton.disabled) {
                    sendMessage();
                }
            }
        });

        const chatContainerEl = document.getElementById('chatContainer');
        const scrollBtnEl = document.getElementById('scrollToBottomButton');

        chatContainerEl.addEventListener('scroll', () => {
            const threshold = 80;
            const atBottom = chatContainerEl.scrollHeight - chatContainerEl.scrollTop - chatContainerEl.clientHeight < threshold;
            autoScroll = atBottom;
            scrollBtnEl.style.display = autoScroll ? 'none' : 'flex';
        });

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('collapsed');
        }

        function toggleSessionsSidebar() {
            const sidebar = document.getElementById('sessionsSidebar');
            const wasCollapsed = sidebar.classList.contains('collapsed');
            sidebar.classList.toggle('collapsed');
            
            // Load sessions when opening
            if (wasCollapsed) {
                loadSessionsList();
            }
        }

        function triggerPaperUpload() {
            const ensureSession = async () => {
                if (sessionId) return;
                try {
                    const res = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                    if (res.ok) {
                        const data = await res.json();
                        sessionId = data.session_id;
                        updateActiveSessionLabel(null, sessionId);
                        try { window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId); } catch {}
                        // Persist empty context so subsequent uploads attach cleanly
                        await saveSessionContext();
                    }
                } catch (e) {
                    console.warn('Could not ensure session before upload', e);
                }
            };

            ensureSession().finally(() => {
                const input = document.getElementById('paperUploadInput');
                input.value = '';
                input.click();
            });
        }

        async function uploadPapers(files) {
            const formData = new FormData();
            for (const file of files) {
                if (!file.name.toLowerCase().endsWith('.pdf')) continue;
                formData.append('files', file);
            }
            if (!formData.has('files')) return;
            if (sessionId) {
                formData.append('session_id', sessionId);
            }

            const uploadBtn = document.getElementById('uploadButton');
            const originalText = uploadBtn.textContent;
            uploadBtn.disabled = true;
            uploadBtn.textContent = '‚è≥ Uploading...';
            
            isIndexing = true;
            updateInputState();

            try {
                const response = await fetch(`${API_URL}/papers/upload`, {
                    method: 'POST',
                    body: formData,
                });
                if (!response.ok) {
                    throw new Error('Failed to upload papers');
                }

                const data = await response.json();
                const uploadedIds = (data.papers || []).map(p => p.id);

                // Trust backend as source of truth: reload the full session
                if (sessionId) {
                    await loadSession(sessionId);
                } else {
                    // No session should be rare (we ensure before upload), fallback to show uploaded only
                    await loadPapers(uploadedIds);
                }

                uploadBtn.textContent = `‚úì Uploaded (${data.total_count})`;
                setTimeout(() => {
                    uploadBtn.textContent = originalText;
                }, 2000);
            } catch (error) {
                console.error('Error uploading papers:', error);
                uploadBtn.textContent = '‚úó Upload error';
                setTimeout(() => {
                    uploadBtn.textContent = originalText;
                }, 2000);
            } finally {
                uploadBtn.disabled = false;
                isIndexing = false;
                updateInputState();
            }
        }

        function openMindmap() {
            // Open the mindmap visualization in a new tab.
            // Always go through the query-based generation path so that
            // the default generic mindmap and custom queries behave
            // consistently and reflect the current papers.

            const baseDefault = 'Organize the content into meaningful themes and subtopics.';
            const trimmedQuery = (mindmapQuery || '').trim() || baseDefault;

            let url = '/mindmap';
            const qs = new URLSearchParams();

            // Always pass session_id to scope mindmap to current session's papers
            if (sessionId) {
                qs.set('session_id', sessionId);
            }

            // If a specific paper is selected, also pass paper_id for single-paper view
            if (selectedPaperId) {
                qs.set('paper_id', selectedPaperId);
            }

            // Always pass an explicit query so the backend uses the
            // same generation/caching pipeline for both default and
            // user-specified instructions.
            qs.set('query', trimmedQuery);

            const qsString = qs.toString();
            if (qsString) {
                url += `?${qsString}`;
            }

            window.open(url, '_blank');
        }

        function openCitationMap(paperId) {
            const targetId = paperId || selectedPaperId;
            if (!targetId) {
                alert('Please select a paper first to view its citation map.');
                return;
            }
            const url = `/mindmap?mode=citations&paper_id=${targetId}`;
            window.open(url, '_blank');
        }

        function editMindmapQuery() {
            const baseDefault = 'Organize the content into meaningful themes and subtopics.';
            const scopedDefault = 'Organize this paper\'s content into its main topics and subtopics.';
            const currentDefault = selectedPaperId ? scopedDefault : baseDefault;

            const existing = mindmapQuery && mindmapQuery.trim() ? mindmapQuery : currentDefault;
            const updated = window.prompt('Mindmap instructions (optional):', existing);
            if (updated === null) {
                return; // user cancelled
            }
            const trimmed = updated.trim();
            mindmapQuery = trimmed;
        }

        async function loadPapers(filterIds) {
            try {
                const response = await fetch(`${API_URL}/papers`);
                const data = await response.json();
                
                const papersList = document.getElementById('papersList');
                const paperCount = document.getElementById('paperCount');
                const allPapers = data.papers || [];

                // If filterIds is explicitly provided (even if empty), use it
                // Otherwise (undefined/null), show all papers
                const hasFilter = Array.isArray(filterIds);
                const effectiveIds = hasFilter ? new Set(filterIds) : null;

                const scopedPapers = hasFilter
                    ? allPapers.filter(p => effectiveIds.has(p.id))
                    : allPapers;

                // For session context, only track the IDs of the
                // papers actually visible in this view, not all
                // globally indexed papers. This keeps sessions
                // properly scoped even across multiple windows.
                currentPaperIds = scopedPapers.map(p => p.id);
                paperCount.textContent = scopedPapers.length;

                if (!scopedPapers.length) {
                    papersList.innerHTML = '<div class="empty-state">No papers available</div>';
                    return;
                }

                papersList.innerHTML = scopedPapers.map(paper => {
                    const displayName = paper.canonical_title && paper.canonical_title.trim()
                        ? paper.canonical_title
                        : paper.filename;
                    return `
                    <div class="paper-item" data-paper-id="${paper.id}">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 6px;">
                            <div style="flex: 1;" onclick="selectPaper('${paper.id}')">
                                <div class="paper-name">${displayName}</div>
                                <div class="paper-meta">${paper.page_count} pages</div>
                            </div>
                            <button
                                type="button"
                                title="View Citation Map"
                                style="border: none; background: transparent; cursor: pointer; font-size: 14px; padding: 0 4px;"
                                onclick="event.stopPropagation(); openCitationMap('${paper.id}')"
                            >
                                üï∏Ô∏è
                            </button>
                            <button
                                type="button"
                                title="Remove from this chat session"
                                style="border: none; background: transparent; color: #b00020; cursor: pointer; font-size: 14px; padding: 0 4px;"
                                onclick="event.stopPropagation(); removePaperFromSession('${paper.id}')"
                            >
                                ‚úï
                            </button>
                        </div>
                    </div>
                `;}).join('');
            } catch (error) {
                console.error('Error loading papers:', error);
                papersList.innerHTML = '<div class="empty-state">Error loading papers</div>';
            }
        }

        async function selectPaper(paperId) {
            if (!sessionId) return;
            
            // Toggle selection
            const newSelection = selectedPaperId === paperId ? null : paperId;
            
            try {
                // Update backend first
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: newSelection,
                        paper_ids: currentPaperIds,
                    }),
                });
                
                if (res.ok) {
                    // Backend updated, reload session to sync UI
                    await loadSession(sessionId);
                }
            } catch (err) {
                console.error('Failed to update selected paper', err);
            }
        }

        async function sendMessage() {
            if (isLoading || isIndexing) return;
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            isLoading = true;
            updateInputState();
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            adjustHeight(); // Reset height
            
            // Show loading indicator and create placeholder for streaming response
            const chatContainer = document.getElementById('chatContainer');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.textContent = 'Thinking...';
            loadingDiv.id = 'loading';
            chatContainer.appendChild(loadingDiv);
            if (autoScroll) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            
            // Create assistant message div for streaming
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant';
            messageDiv.id = 'streaming-message';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-button';
            copyBtn.type = 'button';
            copyBtn.textContent = '‚ßâ';
            copyBtn.title = 'Copy response';
            copyBtn.onclick = () => copyAssistantMessage(messageDiv);
            messageDiv.appendChild(copyBtn);

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.id = 'streaming-content';
            messageDiv.appendChild(contentDiv);
            
            try {
                // Prefer EventSource (GET SSE) for reliable streaming
                const params = new URLSearchParams();
                params.set('message', message);
                if (sessionId) params.set('session_id', sessionId);
                if (selectedPaperId) params.set('paper_id', selectedPaperId);

                const sseUrl = `${API_URL}/chat/stream?${params.toString()}`;

                // Remove loading indicator and add streaming container
                document.getElementById('loading').remove();
                chatContainer.appendChild(messageDiv);

                const es = new EventSource(sseUrl);
                let fullText = '';
                isStreaming = true;

                es.onmessage = async (evt) => {
                    try {
                        const data = JSON.parse(evt.data);
                        if (data.type === 'session') {
                            const newId = data.session_id;
                            if (sessionId !== newId) {
                                sessionId = newId;
                                updateActiveSessionLabel(null, sessionId);
                            }
                            try {
                                window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                            } catch (e) {
                                console.warn('Could not persist last session id', e);
                            }
                            // Persist the current sidebar paper set as the
                            // initial context for this session so the backend
                            // and AI agent see exactly the same papers.
                            // If the user uploaded papers in this window
                            // before sending the first message, currentPaperIds
                            // already reflects those, so the very first
                            // response will be correctly scoped.
                            await saveSessionContext({ reload: false });
                            return;
                        }
                        if (data.type === 'session_created') {
                            // Backend created a new session - refresh sessions sidebar
                            const sessionsSidebar = document.getElementById('sessionsSidebar');
                            if (sessionsSidebar && !sessionsSidebar.classList.contains('collapsed')) {
                                await loadSessionsList();
                            }
                            return;
                        }
                        if (data.type === 'image') {
                            // Render generated image inline
                            const img = document.createElement('img');
                            img.src = data.data_url;
                            img.alt = 'Generated visualization';
                            img.style.maxWidth = '100%';
                            img.style.borderRadius = '8px';
                            img.style.display = 'block';
                            img.style.marginBottom = '8px';
                            messageDiv.insertBefore(img, contentDiv);
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                            return;
                        }
                        if (data.type === 'chunk') {
                            fullText += data.text;
                            if (typeof marked !== 'undefined') {
                                contentDiv.innerHTML = marked.parse(fullText);
                                attachCodeBlockCopyButtons(contentDiv);
                            } else {
                                contentDiv.textContent = fullText;
                            }
                            if (autoScroll) {
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                            return;
                        }
                        if (data.type === 'done') {
                            const sourcePapers = data.source_papers || [];
                            if (sourcePapers.length > 0) {
                                const sourcesDiv = document.createElement('div');
                                sourcesDiv.className = 'message-sources';
                                sourcesDiv.textContent = `Sources: ${sourcePapers.join(', ')}`;
                                messageDiv.appendChild(sourcesDiv);
                            }
                            if (data.token_usage) {
                                await updateTokenStats();
                            }

                            // Ensure latest paper context is persisted with the session
                            await saveSessionContext({ reload: false });
                            
                            es.close();
                            isStreaming = false;
                            isLoading = false;
                            adjustHeight();
                            input.focus();
                            // Remove streaming IDs
                            messageDiv.removeAttribute('id');
                            contentDiv.removeAttribute('id');
                        }
                        if (data.type === 'error') {
                            const msg = data.message || 'Server error';
                            // Preserve any streamed content and append a
                            // warning instead of overwriting the answer.
                            const errDiv = document.createElement('div');
                            errDiv.style.marginTop = '8px';
                            errDiv.style.fontSize = '12px';
                            errDiv.style.color = '#b00020';
                            errDiv.textContent = 'Warning: ' + msg;
                            messageDiv.appendChild(errDiv);
                            es.close();
                            isStreaming = false;
                            isLoading = false;
                            adjustHeight();
                            input.focus();
                            return;
                        }
                    } catch (e) {
                        console.error('SSE parse error', e);
                    }
                };

                es.onerror = () => {
                    // Stream ended or failed; UI already shows any error
                    es.close();
                    isStreaming = false;
                    isLoading = false;
                    adjustHeight();
                    input.focus();
                };

            } catch (error) {
                console.error('Error sending message:', error);
                const loadingElem = document.getElementById('loading');
                if (loadingElem) {
                    loadingElem.textContent = 'Error: Could not get response';
                } else {
                    addMessage('Error: Could not get response', 'assistant');
                }
                
                // Remove streaming message if it exists
                const streamingMsg = document.getElementById('streaming-message');
                if (streamingMsg) streamingMsg.remove();
                isStreaming = false;
                isLoading = false;
                adjustHeight();
                input.focus();
            }
        }

        function addMessage(content, role, sources = []) {
            const chatContainer = document.getElementById('chatContainer');
            
            // Remove empty state if exists
            const emptyState = chatContainer.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            if (role === 'assistant') {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-button';
                copyBtn.type = 'button';
                copyBtn.textContent = '‚ßâ';
                copyBtn.title = 'Copy response';
                copyBtn.onclick = () => copyAssistantMessage(messageDiv, content);
                messageDiv.appendChild(copyBtn);
            }

            // Create content div
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // For assistant messages, parse markdown
            if (role === 'assistant' && typeof marked !== 'undefined') {
                // Configure marked for better formatting
                marked.setOptions({
                    breaks: true,
                    gfm: true
                });
                contentDiv.innerHTML = marked.parse(content);
                attachCodeBlockCopyButtons(contentDiv);
            } else {
                // For user messages, use plain text
                contentDiv.textContent = content;
            }
            
            messageDiv.appendChild(contentDiv);
            
            if (sources && sources.length > 0) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.className = 'message-sources';
                sourcesDiv.textContent = `Sources: ${sources.join(', ')}`;
                messageDiv.appendChild(sourcesDiv);
            }
            
            chatContainer.appendChild(messageDiv);
            if (autoScroll) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        async function copyAssistantMessage(messageElement, fallbackText) {
            try {
                const contentEl = messageElement.querySelector('.message-content');
                let textToCopy = fallbackText || '';

                if (!textToCopy && contentEl) {
                    // Prefer the underlying markdown/text, but fall back to visible text
                    textToCopy = contentEl.textContent || '';
                }

                if (!textToCopy) return;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = textToCopy;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }

                const btn = messageElement.querySelector('.copy-button');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = '‚úì';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = original;
                        btn.classList.remove('copied');
                    }, 1200);
                }
            } catch (e) {
                console.error('Copy failed', e);
            }
        }

        function attachCodeBlockCopyButtons(container) {
            const blocks = container.querySelectorAll('pre > code');
            blocks.forEach((codeEl) => {
                const pre = codeEl.parentElement;
                if (!pre || pre.querySelector('.code-copy-button')) {
                    return;
                }

                const btn = document.createElement('button');
                btn.className = 'code-copy-button';
                btn.type = 'button';
                btn.textContent = 'Copy';
                btn.title = 'Copy code';
                btn.onclick = async (e) => {
                    e.stopPropagation();
                    const text = codeEl.textContent || '';
                    if (!text) return;

                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(text);
                        } else {
                            const textarea = document.createElement('textarea');
                            textarea.value = text;
                            textarea.style.position = 'fixed';
                            textarea.style.opacity = '0';
                            document.body.appendChild(textarea);
                            textarea.focus();
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                        }

                        btn.classList.add('copied');
                        const original = btn.textContent;
                        btn.textContent = 'Copied';
                        setTimeout(() => {
                            btn.textContent = original;
                            btn.classList.remove('copied');
                        }, 1200);
                    } catch (err) {
                        console.error('Code block copy failed', err);
                    }
                };

                pre.appendChild(btn);
            });
        }

        function scrollToBottom() {
            const chatContainer = document.getElementById('chatContainer');
            autoScroll = true;
            chatContainer.scrollTop = chatContainer.scrollHeight;
            const scrollBtnEl = document.getElementById('scrollToBottomButton');
            scrollBtnEl.style.display = 'none';
        }

        async function showSessions() {
            // Deprecated - now using sidebar
            toggleSessionsSidebar();
        }

        async function loadSessionsList() {
            try {
                const url = `${API_URL}/chat/sessions`;
                const res = await fetch(url);
                const data = await res.json();
                const sessions = data.sessions || [];
                
                const sessionsList = document.getElementById('sessionsList');
                
                if (!sessions.length) {
                    sessionsList.innerHTML = '<div class="empty-state" style="padding: 20px; text-align: center; color: #999; font-size: 13px;">No saved sessions</div>';
                    return;
                }

                sessionsList.innerHTML = sessions.map(s => {
                    const isActive = s.session_id === sessionId;
                    const shortId = s.session_id.slice(0, 8);
                    const date = new Date(s.updated_at);
                    const timeStr = date.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    const displayName = s.session_name || `Session ${shortId}...`;
                    
                    return `
                        <div class="session-item ${isActive ? 'active' : ''}" onclick="switchToSession('${s.session_id}')">
                            <div class="session-info">
                                <span class="session-id-label" 
                                      title="Click to rename" 
                                      ondblclick="event.stopPropagation(); renameSession('${s.session_id}', this)"
                                      style="cursor: pointer; font-weight: 500; font-size: 13px; color: #333; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block;">${displayName}</span>
                                <button 
                                    class="session-delete-btn" 
                                    onclick="event.stopPropagation(); deleteSessionById('${s.session_id}')"
                                    title="Delete session"
                                >‚úï</button>
                            </div>
                            <div class="session-meta">
                                ${s.message_count || 0} messages ‚Ä¢ ${s.total_tokens || 0} tokens
                            </div>
                            <div class="session-meta">
                                ${timeStr}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                console.error('Failed to list sessions', err);
            }
        }

        async function switchToSession(id) {
            if (id === sessionId) return; // Already active
            await loadSession(id);
            // Refresh the sessions list to update active state
            await loadSessionsList();
        }

        async function deleteSessionById(id) {
            if (!confirm('Delete this session?')) return;
            
            try {
                await fetch(`${API_URL}/chat/session/${id}`, { method: 'DELETE' });
                
                // If we deleted the active session, create a new one
                if (id === sessionId) {
                    await newSession();
                }
                
                // Refresh the sessions list
                await loadSessionsList();
            } catch (e) {
                console.error('Failed to delete session', e);
            }
        }

        async function renameSession(sessionIdToRename, element) {
            const currentName = element.textContent.trim();
            const newName = window.prompt('Enter new session name:', currentName);
            
            if (newName === null || newName.trim() === '') {
                return; // User cancelled or empty name
            }
            
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionIdToRename}/name`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_name: newName.trim() }),
                });
                
                if (res.ok) {
                    // Refresh the sessions list to show updated name
                    await loadSessionsList();
                    if (sessionIdToRename === sessionId) {
                        updateActiveSessionLabel(newName.trim(), sessionId);
                    }
                } else {
                    alert('Failed to rename session');
                }
            } catch (e) {
                console.error('Failed to rename session', e);
                alert('Error renaming session');
            }
        }

        function updateChatBackground() {
            const chatContainer = document.getElementById('chatContainer');
            if (selectedPaperId) {
                chatContainer.classList.add('specialized');
            } else {
                chatContainer.classList.remove('specialized');
            }
        }

        async function loadSession(id) {
            try {
                const res = await fetch(`${API_URL}/chat/session/${id}`);
                if (!res.ok) {
                    alert('Session not found');
                    return;
                }
                const conversation = await res.json();

                sessionId = conversation.session_id;
                updateActiveSessionLabel(conversation.session_name, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                const messages = conversation.messages || [];
                const selected = conversation.selected_paper_id || null;
                const sessionPaperIds = conversation.paper_ids || [];

                // Refresh papers list scoped to this session's paper_ids
                await loadPapers(sessionPaperIds);

                // Restore selected paper in UI if it still exists
                selectedPaperId = selected && sessionPaperIds.includes(selected) ? selected : null;
                document.querySelectorAll('.paper-item').forEach(item => {
                    if (selectedPaperId && item.dataset.paperId === selectedPaperId) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });

                // Re-render chat history
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '';
                for (const msg of messages) {
                    const role = msg.role === 'assistant' ? 'assistant' : 'user';
                    addMessage(msg.content, role, msg.source_papers || []);
                }

                updateChatBackground();
                await updateTokenStats();

                // Ensure we are scrolled to the latest message after reload
                try {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                } catch {}
            } catch (err) {
                console.error('Failed to load session', err);
                alert('Error loading session');
            }
        }

        async function clearChat() {
            if (!sessionId) {
                // No session, just clear UI
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
                autoScroll = true;
                return;
            }

            try {
                // Clear messages from backend
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/clear`, {
                    method: 'POST',
                });
                
                if (!res.ok) {
                    console.error('Failed to clear chat history');
                    return;
                }
                
                // Clear UI
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
                autoScroll = true;
                
                // Update token stats
                await updateTokenStats();
            } catch (e) {
                console.error('Error clearing chat', e);
            }
        }

        async function newSession() {
            const chatContainer = document.getElementById('chatContainer');
            
            // Delete current session if it has no messages (papers don't matter)
            if (sessionId) {
                try {
                    const conv = await fetch(`${API_URL}/chat/session/${sessionId}`);
                    if (conv.ok) {
                        const data = await conv.json();
                        const messages = data.messages || [];
                        
                        // Delete if no messages
                        if (messages.length === 0) {
                            await fetch(`${API_URL}/chat/session/${sessionId}`, { method: 'DELETE' });
                        }
                    }
                } catch (e) {
                    console.warn('Could not check/delete empty session', e);
                }
            }
            
            // Clear UI
            chatContainer.innerHTML = '<div class="empty-state">Ask a question about the papers</div>';
            autoScroll = true;

            // Create a brand new backend session with empty paper_ids
            try {
                const res = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                if (!res.ok) {
                    console.error('Failed to create new chat session');
                    return;
                }
                
                const data = await res.json();
                sessionId = data.session_id;
                updateActiveSessionLabel(null, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                
                // Clear local state before saving to backend
                currentPaperIds = [];
                selectedPaperId = null;
                
                // Persist empty paper context and reload session from backend
                await saveSessionContext();
                
                // UI now follows backend: loadSession will refresh sidebar from backend state
                await loadSession(sessionId);
                
                // Refresh sessions sidebar if open
                const sessionsSidebar = document.getElementById('sessionsSidebar');
                if (!sessionsSidebar.classList.contains('collapsed')) {
                    await loadSessionsList();
                }
            } catch (e) {
                console.error('Error creating new session', e);
            }
        }

        async function deleteSession() {
            if (!sessionId) {
                // Nothing to delete; just create a new empty session
                await newSession();
                return;
            }

            try {
                // Delete current session from backend
                await fetch(`${API_URL}/chat/session/${sessionId}`, { method: 'DELETE' });
            } catch (e) {
                console.error('Error deleting session', e);
            }

            // Create a fresh empty session and reload from backend
            try {
                const createRes = await fetch(`${API_URL}/chat/session`, { method: 'POST' });
                if (createRes.ok) {
                    const data = await createRes.json();
                    sessionId = data.session_id;
                    updateActiveSessionLabel(null, sessionId);
                    try {
                        window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                    } catch (e) {
                        console.warn('Could not persist last session id', e);
                    }
                    
                    // Clear local state before saving
                    currentPaperIds = [];
                    selectedPaperId = null;
                    
                    // Save empty context and reload UI from backend
                    await saveSessionContext();
                    await loadSession(sessionId);
                    
                    // Refresh sessions sidebar if open
                    const sessionsSidebar = document.getElementById('sessionsSidebar');
                    if (!sessionsSidebar.classList.contains('collapsed')) {
                        await loadSessionsList();
                    }
                } else {
                    console.error('Failed to create new session after delete');
                }
            } catch (e) {
                console.error('Error creating new session after delete', e);
            }
        }

        async function resetAllData() {
            const confirmed = window.confirm('This will delete ALL papers, vector DB, conversations, and metadata. This cannot be undone.\n\nAre you sure?');
            if (!confirmed) return;

            try {
                const res = await fetch(`${API_URL}/admin/reset`, { method: 'POST' });
                if (!res.ok) {
                    alert('Failed to reset data');
                    return;
                }

                // After reset, clear local state and reload page for a clean start.
                try {
                    window.sessionStorage.removeItem(LAST_SESSION_KEY);
                } catch (_) {}

                alert('All data has been reset. The page will reload.');
                window.location.reload();
            } catch (e) {
                console.error('Failed to reset all data', e);
                alert('Error resetting data');
            }
        }

        async function removePaperFromSession(paperId) {
            if (!sessionId) return;
            
            try {
                // Fetch current session state from backend
                const res = await fetch(`${API_URL}/chat/session/${sessionId}`);
                if (!res.ok) return;
                
                const data = await res.json();
                const currentPapers = data.paper_ids || [];
                
                // Remove paper from backend state
                const updatedPapers = currentPapers.filter(id => id !== paperId);
                const updatedSelected = data.selected_paper_id === paperId ? null : data.selected_paper_id;
                
                // Update backend first
                const updateRes = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: updatedSelected,
                        paper_ids: updatedPapers,
                    }),
                });
                
                if (updateRes.ok) {
                    // Backend updated successfully, now reload UI from backend
                    await loadSession(sessionId);
                }
            } catch (err) {
                console.error('Failed to remove paper from session', err);
            }
        }

        function updateActiveSessionLabel(name, id) {
            const baseTitle = 'Journal Article AI Assistant';

            if (!id) {
                document.title = baseTitle;
                return;
            }
            
            if (name) {
                document.title = `${name} - ${baseTitle}`;
            } else {
                const shortId = String(id).slice(0, 8);
                document.title = `Session ${shortId} - ${baseTitle}`;
            }
        }

        async function saveSessionContext(opts = {}) {
            if (!sessionId) return;
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/context`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_paper_id: selectedPaperId,
                        paper_ids: currentPaperIds,
                    }),
                });

                if (res.ok) {
                    // After saving, reload the full session from the
                    // backend so the sidebar and local state always
                    // reflect the canonical session context (paper_ids
                    // and selected_paper_id).
                    const shouldReload = opts.reload !== false;
                    if (shouldReload && !isStreaming) {
                        await loadSession(sessionId);
                    }
                }
            } catch (err) {
                console.error('Failed to save session context', err);
            }
        }

        async function updateTokenStats() {
            // Token stats are shown in the sidebar, so refresh the list to update them
            if (sessionId) {
                await loadSessionsList();
            }
        }

        // Auto-resume a previous session on page load; if none exists,
        // create a new empty session just like a first-time launch.
        window.addEventListener('load', async () => {
            try {
                // Load sessions list on page load
                await loadSessionsList();
                
                const lastId = window.sessionStorage.getItem(LAST_SESSION_KEY);
                if (lastId) {
                    const res = await fetch(`${API_URL}/chat/session/${lastId}`);
                    if (res.ok) {
                        await loadSession(lastId);
                        // updateActiveSessionLabel is handled by loadSession
                        return;
                    }
                    // Session no longer exists; clear stored id
                    window.sessionStorage.removeItem(LAST_SESSION_KEY);
                }

                // No valid previous session: create a brand new session
                // so the behavior matches a fresh app launch.
                const createRes = await fetch(`${API_URL}/chat/session`, {
                    method: 'POST',
                });
                if (!createRes.ok) {
                    console.warn('Failed to create initial session');
                    updateActiveSessionLabel(null, null);
                    return;
                }
                const created = await createRes.json();
                sessionId = created.session_id;
                updateActiveSessionLabel(null, sessionId);
                try {
                    window.sessionStorage.setItem(LAST_SESSION_KEY, sessionId);
                } catch (e) {
                    console.warn('Could not persist last session id', e);
                }
                // Persist empty paper context and sync UI from backend
                await saveSessionContext();
                // Refresh sessions list after creating new session
                await loadSessionsList();
            } catch (e) {
                console.warn('Failed to initialize session on load', e);
            }
        });

        async function duplicateSession() {
            if (!sessionId) {
                alert("No active session to duplicate.");
                return;
            }
            
            try {
                const res = await fetch(`${API_URL}/chat/session/${sessionId}/duplicate`, {
                    method: 'POST'
                });
                
                if (res.ok) {
                    const data = await res.json();
                    // Switch to the new session
                    await switchToSession(data.session_id);
                } else {
                    alert("Failed to duplicate session");
                }
            } catch (e) {
                console.error("Error duplicating session", e);
                alert("Error duplicating session");
            }
        }

        function initProgressStream() {
            const evtSource = new EventSource(`${API_URL}/progress`);
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            const status = document.getElementById('progressStatus');
            const percent = document.getElementById('progressPercent');

            evtSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.status === 'processing') {
                        container.style.display = 'block';
                        const pct = Math.round(data.progress || 0);
                        bar.style.width = `${pct}%`;
                        status.textContent = data.message || 'Processing...';
                        percent.textContent = `${pct}%`;
                    } else if (data.status === 'completed') {
                        bar.style.width = '100%';
                        percent.textContent = '100%';
                        status.textContent = 'Done!';
                        
                        // Refresh papers list if we just finished indexing
                        if (sessionId) {
                            loadSession(sessionId);
                        } else {
                            loadPapers();
                        }

                        setTimeout(() => {
                            container.style.display = 'none';
                            bar.style.width = '0%';
                        }, 3000);
                    } else if (data.status === 'error') {
                        status.textContent = 'Error: ' + (data.message || 'Unknown error');
                        status.style.color = '#b00020';
                        setTimeout(() => {
                            container.style.display = 'none';
                            status.style.color = '';
                        }, 5000);
                    }
                } catch (e) {
                    console.error('Error parsing progress event', e);
                }
            };
            
            evtSource.onerror = function(err) {
                // EventSource will try to reconnect automatically
                // We can just log it for debugging
                // console.debug("Progress stream connection lost, reconnecting...", err);
            };
        }

        // Initialize progress stream
        initProgressStream();
    </script>
</body>
</html>
